<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Tudux - Hoy</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 32 32'%3E%3Crect x='3' y='5' width='26' height='24' rx='3' fill='%233B82F6'/%3E%3Crect x='3' y='5' width='26' height='8' rx='3' fill='%232563EB'/%3E%3Crect x='5' y='15' width='22' height='12' rx='1' fill='white'/%3E%3Crect x='9' y='2' width='3' height='6' rx='1.5' fill='white'/%3E%3Crect x='20' y='2' width='3' height='6' rx='1.5' fill='white'/%3E%3Crect x='8' y='18' width='4' height='3' rx='0.5' fill='%233B82F6'/%3E%3Crect x='14' y='18' width='4' height='3' rx='0.5' fill='%233B82F6'/%3E%3Crect x='20' y='18' width='4' height='3' rx='0.5' fill='%233B82F6'/%3E%3Crect x='8' y='22.5' width='4' height='3' rx='0.5' fill='%23CBD5E1'/%3E%3Crect x='14' y='22.5' width='4' height='3' rx='0.5' fill='%23CBD5E1'/%3E%3C/svg%3E">
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }

    :root {
      --bg-primary: #FFFFFF;
      --bg-secondary: #F5F7FA;
      --bg-tertiary: #E8ECF1;
      --bg-app: #E8ECF1;
      --bg-card: #F0F3F7;
      --bg-card-past: #E5E8ED;
      --bg-card-today: #FFFFFF;
      --bg-card-future: #F5F7FA;
      --bg-input: #E8ECF1;
      --bg-sidebar: #FAFBFC;
      --text-primary: #1E293B;
      --text-secondary: #475569;
      --text-muted: #64748B;
      --text-past: #94A3B8;
      --border-color: #CBD5E1;
      --border-light: #E2E8F0;
      --accent-blue: #3B7DD8;
      --accent-green: #2D9469;
      --accent-red: #DC2626;
      --accent-yellow: #D97706;
      --today-bg: #EBF4FF;
      --today-header: #D6E8FC;
      --done-bg: #E8F8F0;
      --done-border: #A7F3D0;
      --temp-color: #4B5563;
      --checkbox-bg: #D1D5DB;
      --effort-bg-today: #C0C5CC;
    }

    [data-theme="dark"] {
      --bg-primary: #0f0f0f;
      --bg-secondary: #141414;
      --bg-tertiary: #1a1a1a;
      --bg-app: #0a0a0a;
      --bg-header: #1a1a1a;
      --bg-categories: #161616;
      --bg-card: #1e1e1e;
      --bg-card-past: #161616;
      --bg-card-today: #242424;
      --bg-card-future: #1a1a1a;
      --bg-input: #2a2a2a;
      --bg-sidebar: #0f0f0f;
      --bg-button: #2a2a2a;
      --bg-button-hover: #333333;
      --text-primary: #e8eaed;
      --text-secondary: #9aa0a6;
      --text-muted: #71767b;
      --text-past: #5a5f66;
      --border-color: #2a2a2a;
      --border-light: #1a1a1a;
      --effort-bg-today: #404040;
      --accent-blue: #5a9cf5;
      --accent-green: #5cb88a;
      --accent-red: #e87777;
      --accent-yellow: #F59E0B;
      --today-bg: #0d1520;
      --today-header: #152030;
      --done-bg: #0f1f18;
      --done-border: #1a3028;
      --temp-color: #6B7280;
      --checkbox-bg: #3a3a3a;
    }

    html { font-size: 130%; }
    body { font-family: 'IBM Plex Sans', -apple-system, sans-serif; background: var(--bg-app); min-height: 100vh; color: var(--text-primary); overflow: hidden; }
    @media (max-width: 600px) { body { overflow: auto; } }

    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: var(--text-muted); border-radius: 3px; }
    .hide-scrollbar::-webkit-scrollbar { display: none; }
    .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

    /* Hide scrollbar when popover is open (body level) */
    body.popover-open ::-webkit-scrollbar { display: none; }
    body.popover-open * { scrollbar-width: none; -ms-overflow-style: none; }

    .collapsible { overflow: hidden; max-height: 0; transition: max-height 0.2s ease-out; }
    .collapsible.expanded { max-height: 3000px; transition: max-height 0.25s ease-in; }

    .popover {
      position: fixed; background: var(--bg-primary); border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.4); padding: 12px; z-index: 10000;
      width: 280px;
    }
    [data-theme="dark"] .popover { background: var(--bg-card); }
    .popover.ready { animation: popIn 0.1s ease-out; }
    @keyframes popIn { from { opacity: 0; transform: scale(0.96); } to { opacity: 1; transform: scale(1); } }

    .draggable { cursor: grab; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
    .draggable:active { cursor: grabbing; }
    .dragging { opacity: 0.4; }
    .drop-zone { transition: background 0.1s; }

    .drop-indicator {
      height: 0;
      background: var(--accent-blue);
      border-radius: 1px;
      margin: 0;
      opacity: 0;
      transition: all 0.1s;
    }
    .drop-indicator.visible {
      height: 2px;
      margin: 2px 0;
      opacity: 1;
    }

    /* ===========================================
       SHIMMER ANIMATIONS
       ===========================================
       1. dropShimmer: Izquierda→Derecha, 300ms - cuando suelto un item
       2. grabShimmer: Derecha→Izquierda, 600ms ease-in - cuando arrastro en mobile
       3. navigateShimmer: Derecha→Izquierda, 300ms - click en item agendado
       =========================================== */

    /* 1. Drop shimmer - 300ms izquierda a derecha */
    @keyframes dropShimmer {
      0% { background-position: -100% 0; }
      100% { background-position: 200% 0; }
    }

    /* 2. Grab shimmer (mobile drag) - 600ms derecha a izquierda con ease-in */
    @keyframes grabShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -100% 0; }
    }

    /* 3. Navigate shimmer (click en agendado) - 300ms derecha a izquierda */
    @keyframes navigateShimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -100% 0; }
    }

    .just-dropped, .just-grabbed, .just-shimmered {
      position: relative;
      overflow: hidden;
    }

    /* Drop: 300ms L→R */
    .just-dropped::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
      animation: dropShimmer 0.3s linear;
      pointer-events: none;
      border-radius: 2px;
    }

    /* Grab (mobile): 200ms delay + 600ms R→L ease-in */
    .just-grabbed::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
      animation: grabShimmer 0.3s linear 0.3s both;
      pointer-events: none;
      border-radius: 2px;
    }

    /* Navigate (click en agendado): 300ms R→L */
    .just-shimmered::after {
      content: '';
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
      animation: navigateShimmer 0.3s linear;
      pointer-events: none;
      border-radius: 2px;
    }

    /* Dark theme variants */
    [data-theme="dark"] .just-dropped::after {
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.15) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
    }
    [data-theme="dark"] .just-grabbed::after {
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.15) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
    }
    [data-theme="dark"] .just-shimmered::after {
      background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.15) 50%, transparent 100%);
      background-size: 50% 100%;
      background-repeat: no-repeat;
    }

    input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; }
    input[type=number] { -moz-appearance: textfield; }

    .btn {
      padding: 3px 8px; background: var(--bg-input); border: none;
      border-radius: 4px; font-size: 0.625rem; color: var(--text-secondary); cursor: pointer; font-weight: 500;
      line-height: 1.4; touch-action: manipulation;
    }
    .btn:hover { background: var(--border-color); }
    [data-theme="dark"] .btn:hover { background: #333; }
    .btn-primary { background: var(--accent-blue); color: #FFF; }
    [data-theme="dark"] .btn-primary { background: #3d6ba3; color: #FFF; }
    .btn-primary:hover { background: #2d5a8a; }
    [data-theme="dark"] .btn-primary:hover { background: #4a7ab5; }
    .btn-primary:disabled { background: var(--text-muted); cursor: not-allowed; }
    .btn-danger { background: var(--accent-red); color: #FFF; }
    [data-theme="dark"] .btn-danger { background: #a85555; color: #FFF; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .btn-icon-danger {
      padding: 6px 8px; background: var(--bg-input); border: none;
      border-radius: 4px; cursor: pointer; color: var(--accent-red); font-size: 0.75rem;
    }
    [data-theme="dark"] .btn-icon-danger { background: var(--bg-card); }
    .btn-icon-danger:hover { background: var(--border-color); }
    [data-theme="dark"] .btn-icon-danger:hover { background: #2a2a2a; }

    .clickable { cursor: pointer; }
    .clickable:hover { opacity: 0.8; }

    .effort-bar {
      width: 20px; height: 5px; background: var(--border-color); border-radius: 2px; overflow: hidden; flex-shrink: 0;
    }
    .effort-bar-fill {
      height: 100%; border-radius: 2px; transition: width 0.2s;
    }

    .slot-container {
      flex: 1; display: flex; flex-direction: column; min-height: 0; overflow: hidden;
    }
    .slots-scrollable {
      flex: 1; overflow-y: auto; min-height: 0; display: flex; flex-direction: column;
    }
    .slot-row {
      padding: 10px;
      min-height: 50px;
    }
    .slot-row:last-child {
      flex: 1;
    }
    .slot-row-done {
      height: 145px; min-height: 145px; max-height: 145px;
      overflow-y: auto; padding: 8px 10px;
      border-top: 1px solid var(--border-light);
    }

    .section-toggle {
      cursor: pointer; user-select: none;
    }
    .section-toggle:hover {
      background: var(--bg-tertiary);
    }

    .category-heading {
      cursor: pointer; user-select: none;
    }
    .category-heading:hover {
      background: var(--bg-tertiary);
    }

    .toast {
      position: fixed; bottom: 20px; left: 0; right: 0;
      margin: 0 auto; width: fit-content;
      background: var(--bg-primary); color: var(--text-primary);
      padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      z-index: 10001;
      display: flex; align-items: center; gap: 12px;
      animation: slideUp 0.2s ease-out;
    }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

    .discard-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); z-index: 10001;
      animation: fadeIn 0.15s ease-out;
    }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .discard-dialog {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: var(--bg-primary); border-radius: 8px; padding: 16px 20px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5); z-index: 10002;
      width: 300px; animation: dialogPopIn 0.15s ease-out;
    }
    @keyframes dialogPopIn { from { opacity: 0; transform: translate(-50%, -50%) scale(0.96); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }
    [data-theme="dark"] .discard-dialog { background: var(--bg-card); }

    /* ===== MOBILE STYLES ===== */
    .mobile-only { display: none; }
    .desktop-only { display: flex; }

    /* Bottom Sheet */
    .bottom-sheet-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5); z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }
    .bottom-sheet-overlay.closing { animation: fadeOut 0.2s ease-out forwards; }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }

    .bottom-sheet {
      position: fixed; left: 0; right: 0; top: 0; bottom: 0;
      background: var(--bg-primary);
      padding: 16px; padding-top: calc(16px + env(safe-area-inset-top, 0px));
      padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      overflow-y: auto; z-index: 10001;
      animation: slideUp 0.3s ease-out;
      display: flex; flex-direction: column;
    }
    .bottom-sheet.closing { animation: slideDown 0.2s ease-out forwards; }
    @keyframes slideUp { from { transform: translateY(100%); } to { transform: translateY(0); } }
    @keyframes slideDown { from { transform: translateY(0); } to { transform: translateY(100%); } }
    [data-theme="dark"] .bottom-sheet { background: var(--bg-card); }

    /* Mobile Footer */
    .mobile-footer {
      display: none;
      background: var(--bg-header);
      border-top: 1px solid var(--border-color);
      padding: 0 20px;
      padding-bottom: env(safe-area-inset-bottom, 0px);
      height: calc(84px + env(safe-area-inset-bottom, 0px));
      touch-action: none;
      position: relative;
    }
    .mobile-footer-inner {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .mobile-footer-section {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    .mobile-footer-section.center {
      justify-content: center;
      gap: 2px;
    }
    .mobile-footer-section.right {
      justify-content: flex-end;
    }
    .mobile-tab-btn {
      padding: 12px 20px;
      border: none;
      background: none;
      font-size: 1.125rem;
      opacity: 0.35;
      filter: grayscale(100%);
      cursor: pointer;
      touch-action: manipulation;
    }
    .mobile-tab-btn.active {
      opacity: 1;
      filter: none;
    }

    /* Mobile media query */
    @media (max-width: 600px) {
      html { font-size: 150%; height: 100%; overflow: hidden; }
      body { height: 100%; margin: 0; overflow: hidden; overscroll-behavior: none; -webkit-tap-highlight-color: transparent; }

      .mobile-only { display: flex; }
      .desktop-only { display: none !important; }

      .mobile-footer { display: flex; }

      /* Toast from top in mobile */
      .toast { width: calc(100vw - 40px); max-width: 400px; bottom: auto; top: calc(20px + env(safe-area-inset-top, 0px)); animation: slideDown 0.2s ease-out; }
      @keyframes slideDown { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }

      /* Sidebar mobile fullwidth */
      .sidebar-mobile { width: 100% !important; border-left: none !important; }

      /* Mobile day scroll with snap */
      .mobile-day-scroll {
        display: flex;
        overflow-x: scroll;
        scroll-snap-type: x mandatory;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        -ms-overflow-style: none;
      }
      .mobile-day-scroll::-webkit-scrollbar { display: none; }
      .mobile-day-column {
        flex: 0 0 100%;
        min-width: 100%;
        scroll-snap-align: start;
        scroll-snap-stop: always;
      }

      /* Larger touch targets */
      .btn { padding: 8px 12px; font-size: 0.6875rem; }
      .item-card { padding: 8px 10px; }

      /* Wider popover for calendar in mobile */
      .popover { width: calc(100vw - 32px); max-width: 360px; }

      /* Mobile calendar alignment - slots get padding */
      .mobile-day-column .slot-row,
      .mobile-day-column .slot-row-done { padding-left: 12px; padding-right: 12px; }
      /* Mobile: no border on done slot, extra padding top */
      .mobile-day-column .slot-row-done { border-top: none; padding-top: 10px; }

      /* Mobile view transition between calendar and categories */
      .mobile-views-container {
        display: flex;
        width: 200%;
        height: 100%;
        transition: transform 0.3s ease-out;
      }
      .mobile-views-container.view-calendar { transform: translateX(0); }
      .mobile-views-container.view-categories { transform: translateX(-50%); }
      .mobile-view-panel {
        width: 50%;
        height: 100%;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
    }

    /* ===== EXTRACTED CSS CLASSES ===== */

    /* Form Controls */
    .form-control {
      width: 100%; border: none; border-radius: 4px;
      background: var(--bg-input); color: var(--text-primary); outline: none;
    }
    .form-control-sm { padding: 6px; font-size: 0.6875rem; }
    .form-control-md { padding: 8px; font-size: 0.75rem; }
    .form-textarea { resize: none; font-family: inherit; }
    .form-label { font-size: 0.625rem; color: var(--text-muted); margin-bottom: 4px; }
    .form-group { margin-bottom: 8px; }
    .form-group-lg { margin-bottom: 10px; }
    .form-group-rel { margin-bottom: 8px; position: relative; }
    .bottom-sheet .form-control { border-radius: 8px; }
    .bottom-sheet .form-group { margin-bottom: 10px; }

    /* Popover content patterns */
    .popover-info { margin-bottom: 12px; font-size: 0.6875rem; color: var(--text-primary); }
    .popover-title { font-weight: 500; margin-bottom: 4px; }
    .popover-subtitle { color: var(--text-muted); }
    .popover-actions { display: flex; gap: 8px; }
    .popover-actions-col { display: flex; flex-direction: column; gap: 6px; }

    /* Button variants */
    .btn-action { padding: 10px 12px; text-align: left; font-size: 0.6875rem; }
    .btn-action-hint { color: var(--text-muted); font-size: 0.625rem; margin-top: 2px; }
    .btn-submit { flex: 1; padding: 8px; }
    .btn-submit-lg { flex: 1; padding: 10px; }

    /* Icon container */
    .icon-box { display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
    .icon-box-sm { width: 20px; height: 20px; }
    .icon-box-md { width: 24px; height: 24px; }

    /* Checkbox inner */
    .checkbox-inner { display: flex; align-items: center; justify-content: center; border-radius: 3px; flex-shrink: 0; }

    /* Mini Calendar */
    .mini-calendar { padding: 8px; background: var(--bg-card); border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
    .mini-calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .mini-calendar-month { font-size: 0.6875rem; font-weight: 600; text-transform: capitalize; }
    .mini-calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px; margin-bottom: 8px; }
    .mini-calendar-day-label { text-align: center; font-size: 0.5625rem; color: var(--text-muted); padding: 2px; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
    .modal-body { background: var(--bg-secondary); border-radius: 12px; padding: 20px; width: 90%; max-width: 400px; max-height: 80vh; overflow: auto; }

    /* Warning box */
    .warning-box { padding: 8px; background: rgba(239, 68, 68, 0.15); border-radius: 6px; font-size: 0.625rem; color: #EF4444; }

    /* Discard dialog text */
    .dialog-title { font-size: 0.8125rem; font-weight: 600; margin-bottom: 8px; color: var(--text-primary); }
    .dialog-text { font-size: 0.6875rem; color: var(--text-secondary); margin-bottom: 16px; }

    /* Column layout (DayColumn / CategoryColumnSimple) */
    .column-header { padding: 10px 12px 2px 16px; min-height: 28px; cursor: pointer; display: flex; align-items: baseline; justify-content: space-between; }
    .column-items { flex: 1; overflow-y: auto; padding: 0 10px 8px 16px; display: flex; flex-direction: column; }
    .column-click-area { min-height: 80px; flex: 1; cursor: pointer; }

    /* Dashed add button */
    .btn-add-dashed {
      width: 100%; padding: 4px 8px; background: transparent;
      border: 1px dashed var(--border-color); border-radius: 4px;
      color: var(--text-muted); font-size: 0.5625rem; cursor: pointer;
    }

    /* Category elements */
    .cat-swatch { width: 12px; height: 12px; border-radius: 3px; margin-right: 10px; }
    .cat-swatch-lg { width: 24px; height: 24px; border-radius: 4px; flex-shrink: 0; cursor: pointer; }
    .cat-name { font-weight: 600; font-size: 0.8125rem; flex: 1; }
    .color-picker-dropdown {
      position: absolute; top: 100%; left: 32px; margin-top: 4px; padding: 8px;
      background: var(--bg-card); border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      z-index: 10; display: flex; gap: 4px; flex-wrap: wrap; width: 140px;
    }

    /* Desktop layout */
    .app-desktop { height: 100vh; display: flex; flex-direction: column; background: var(--bg-app); }
    .calendar-row { flex: 0 0 59%; display: flex; flex-direction: column; overflow: hidden; border-bottom: 1px solid var(--border-color); }
    .categories-row { flex: 0 0 45%; display: flex; flex-direction: column; overflow: hidden; background: var(--bg-header); }
    .header-bar { padding: 8px 10px; background: var(--bg-header); border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 8px; height: 44px; }
    .calendar-scroll { flex: 1; display: flex; overflow-x: auto; overflow-y: hidden; background: var(--bg-primary); }
    .categories-scroll { flex: 1; display: flex; overflow-x: auto; overflow-y: hidden; }

    /* Mobile layout */
    .app-mobile { height: 100dvh; display: flex; flex-direction: column; background: var(--bg-app); padding-top: env(safe-area-inset-top); overflow: hidden; }
    .floating-header { position: fixed; top: calc(10px + env(safe-area-inset-top, 0px)); right: 20px; z-index: 100; display: flex; pointer-events: none; gap: 6px; align-items: center; }
    .fab { position: absolute; top: -84px; right: 20px; font-size: 0.9rem; padding: 18px 30px; border-radius: 300px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); touch-action: manipulation; z-index: 100; }
    .footer-tab { flex: 1; display: flex; align-items: center; padding: 0 20px; padding-bottom: env(safe-area-inset-bottom, 0px); border: none; background: transparent; cursor: pointer; height: 100%; }
    .footer-tab-left { justify-content: flex-end; }
    .footer-tab-right { justify-content: flex-start; }

    /* Bottom sheet sticky header */
    .bs-header { position: sticky; top: 0; z-index: 10; display: flex; justify-content: space-between; align-items: center; padding: 0 16px 12px; margin: 0 -16px 12px; border-bottom: 1px solid var(--border-color); background: inherit; }

    /* Bottom sheet action buttons */
    .bs-action-btn { flex: 1; padding: 12px; display: flex; align-items: center; justify-content: center; gap: 8px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.75rem; }

    /* Section toggle content row */
    .section-toggle-content { display: flex; align-items: center; justify-content: space-between; gap: 4px; padding: 2px 0; }
    .section-toggle-arrow { transition: transform 0.15s; font-size: 0.5rem; }
    .section-toggle-label { font-size: 0.5625rem; font-weight: 500; }

    /* Slot header and items area */
    .slot-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
    .slot-label { font-size: 0.5625rem; font-weight: 400; }
    .slot-items { flex: 1; min-height: 20px; display: flex; flex-direction: column; }

    /* Category modal row */
    .cat-modal-row { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-primary); border-radius: 8px; cursor: grab; position: relative; }

    /* Utility */
    .flex-spacer { flex: 1; }
    .nav-group { display: flex; align-items: center; gap: 4px; }
    .btn-top-adjust { position: relative; top: -1px; }

    /* Toast */
    .toast-message { font-size: 0.75rem; }
    .toast-undo { padding: 4px 10px; font-size: 0.6875rem; }

    /* Add category cell */
    .add-cat-cell { flex: 0 0 60px; display: flex; align-items: center; justify-content: center; border-right: 1px solid var(--border-color); height: 100%; cursor: pointer; }
    .add-cat-plus { font-size: 1.25rem; font-weight: 400; color: var(--text-muted); }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect, useLayoutEffect, useMemo, useCallback } = React;

    const TEMP_COLOR = '#9CA3AF';
    const COLORS = ['#DC2626','#EA580C','#D97706','#65A30D','#059669','#0D9488','#2563EB','#7C3AED','#DB2777'];
    const DAYS = ['Dom','Lun','Mar','Mié','Jue','Vie','Sáb'];
    const DAYS_FULL = ['Domingo','Lunes','Martes','Miércoles','Jueves','Viernes','Sábado'];
    const MONTHS = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];

    // Column widths - both calendar and category columns are same width
    const DAY_WIDTH = 240;
    const CATEGORY_WIDTH = 200;

    const initialCategories = [
      { id: 'temp', name: 'Temp', color: TEMP_COLOR, isFixed: true },
      { id: 'ai', name: 'AI agents', color: '#0D9488' },
      { id: 'work', name: 'Trabajo', color: '#D97706' },
      { id: 'health', name: 'Salud', color: '#DC2626' },
      { id: 'social', name: 'Social', color: '#DB2777' },
      { id: 'music', name: 'Música', color: '#4F46E5' },
      { id: 'entertainment', name: 'Entretenimiento', color: '#7C3AED' },
      { id: 'home', name: 'Hogar', color: '#65A30D' },
      { id: 'fitness', name: 'Fitness', color: '#059669' },
    ];

    const initialItems = [
      // AI agents
      { id: 1, title: 'Armar prototipo nuevo', category: 'ai', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '', isImportant: true, sortOrder: -10 },
      { id: 2, title: 'Mejorar prompts de código', category: 'ai', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 3, title: 'Probar Kimi K2.5', category: 'ai', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: true, repeat: null, description: '' },
      { id: 9, title: 'Revisar código OpenClaw', category: 'ai', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '', isImportant: true, sortOrder: -9 },
      { id: 110, title: 'Leer artículo RL', category: 'ai', effort: 1, scheduledDate: '2026-02-06', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 111, title: 'Testear Claude 4', category: 'ai', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 112, title: 'Documentar agentes', category: 'ai', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 200, title: 'Investigar MCP', category: 'ai', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-18', isArchived: false, repeat: null, description: '' },
      { id: 201, title: 'Probar Gemini 2.5', category: 'ai', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-17', isArchived: false, repeat: null, description: '' },
      { id: 400, title: 'Leer paper LLM routing', category: 'ai', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 401, title: 'Configurar RAG local', category: 'ai', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 402, title: 'Benchmarks de velocidad', category: 'ai', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 403, title: 'Fine-tuning experimento', category: 'ai', effort: 3, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-05', isArchived: false, repeat: null, description: '' },

      // Trabajo
      { id: 10, title: 'Comprar verduras', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-31', isArchived: false, repeat: null, description: '' },
      { id: 11, title: 'Responder emails', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: true, completedDate: '2026-02-05', createdAt: '2026-01-31', isArchived: false, repeat: null, description: '' },
      { id: 12, title: 'Preparar presentación', category: 'work', effort: 3, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-29', isArchived: false, repeat: null, description: '' },
      { id: 13, title: 'Revisar inversiones', category: 'work', effort: 2, scheduledDate: '2026-02-07', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-18', isArchived: false, repeat: null, description: '' },
      { id: 108, title: 'Review código equipo', category: 'work', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 109, title: 'Planificar semana', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 113, title: 'Llamar cliente', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 114, title: 'Enviar propuesta', category: 'work', effort: 2, scheduledDate: '2026-02-08', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 115, title: 'Actualizar CV', category: 'work', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 202, title: 'Revisar contratos', category: 'work', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: false, repeat: null, description: '' },
      { id: 203, title: 'Organizar archivos', category: 'work', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-14', isArchived: false, repeat: null, description: '' },
      { id: 404, title: 'Preparar agenda semanal', category: 'work', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 405, title: 'Escribir informe mensual', category: 'work', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 406, title: 'Contactar proveedores', category: 'work', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 407, title: 'Revisar presupuesto Q2', category: 'work', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-06', isArchived: false, repeat: null, description: '' },

      // Salud
      { id: 107, title: 'Vitaminas', category: 'health', effort: 0, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-01', isArchived: false, repeat: { type: 'weekdays', days: [1, 4] }, repeatBaseId: 'vitaminas', description: '' },
      { id: 116, title: 'Turno dentista', category: 'health', effort: 1, scheduledDate: '2026-02-06', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 117, title: 'Comprar medicamentos', category: 'health', effort: 1, scheduledDate: '2026-02-09', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 204, title: 'Chequeo anual', category: 'health', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 424, title: 'Renovar receta', category: 'health', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 425, title: 'Pedir turno oftalmólogo', category: 'health', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-06', isArchived: false, repeat: null, description: '' },
      { id: 426, title: 'Análisis de sangre', category: 'health', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-04', isArchived: false, repeat: null, description: '' },

      // Social
      { id: 7, title: 'Llamar a mamá', category: 'social', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 8, title: 'Organizar juntada', category: 'social', effort: 1, scheduledDate: '2026-02-09', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 118, title: 'Cumpleaños Pablo', category: 'social', effort: 1, scheduledDate: '2026-02-07', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 119, title: 'Cena con amigos', category: 'social', effort: 1, scheduledDate: '2026-02-10', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 205, title: 'Visitar abuelos', category: 'social', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 427, title: 'Escribir a Juan', category: 'social', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: false, repeat: null, description: '' },
      { id: 428, title: 'Planear viaje grupal', category: 'social', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 429, title: 'Responder mensajes pendientes', category: 'social', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },

      // Música
      { id: 132, title: 'Practicar teclado', category: 'music', effort: 1, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-02-02', isArchived: false, repeat: { type: 'days', every: 3, startDate: '2026-02-02' }, description: '' },
      { id: 130, title: 'Practicar guitarra', category: 'music', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 131, title: 'Escuchar álbum nuevo', category: 'music', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 206, title: 'Comprar cuerdas', category: 'music', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-18', isArchived: false, repeat: null, description: '' },
      { id: 207, title: 'Aprender canción nueva', category: 'music', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: false, repeat: null, description: '' },
      { id: 408, title: 'Grabar demo', category: 'music', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 409, title: 'Afinar piano', category: 'music', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 410, title: 'Ver tutorial acordes jazz', category: 'music', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 411, title: 'Organizar partituras', category: 'music', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-06', isArchived: false, repeat: null, description: '' },

      // Entretenimiento
      { id: 4, title: 'Ver Severance S2', category: 'entertainment', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 5, title: 'Jugar Balatro', category: 'entertainment', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 6, title: 'Terminar Elden Ring DLC', category: 'entertainment', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-05', isArchived: true, repeat: null, description: '' },
      { id: 120, title: 'Leer libro nuevo', category: 'entertainment', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 121, title: 'Ver película', category: 'entertainment', effort: 1, scheduledDate: '2026-02-08', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 208, title: 'Terminar serie', category: 'entertainment', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 209, title: 'Probar juego nuevo', category: 'entertainment', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 412, title: 'Ver documental naturaleza', category: 'entertainment', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-06', isArchived: false, repeat: null, description: '' },
      { id: 413, title: 'Escuchar podcast historia', category: 'entertainment', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-04', isArchived: false, repeat: null, description: '' },
      { id: 414, title: 'Empezar libro nuevo', category: 'entertainment', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-02', isArchived: false, repeat: null, description: '' },
      { id: 415, title: 'Ir al cine', category: 'entertainment', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2025-12-28', isArchived: false, repeat: null, description: '' },

      // Hogar
      { id: 106, title: 'Regar plantas', category: 'home', effort: 0, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-01', isArchived: false, repeat: { type: 'weekdays', days: [0, 3] }, repeatBaseId: 'plantas', description: '' },
      { id: 122, title: 'Limpiar casa', category: 'home', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 123, title: 'Comprar supermercado', category: 'home', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 124, title: 'Pagar facturas', category: 'home', effort: 1, scheduledDate: '2026-02-06', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 125, title: 'Ordenar armario', category: 'home', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 210, title: 'Arreglar grifo', category: 'home', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: false, repeat: null, description: '' },
      { id: 211, title: 'Cambiar focos', category: 'home', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 416, title: 'Limpiar ventanas', category: 'home', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },
      { id: 417, title: 'Organizar garage', category: 'home', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-06', isArchived: false, repeat: null, description: '' },
      { id: 418, title: 'Llamar plomero', category: 'home', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-04', isArchived: false, repeat: null, description: '' },
      { id: 419, title: 'Comprar plantas nuevas', category: 'home', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-02', isArchived: false, repeat: null, description: '' },

      // Fitness
      { id: 101, title: 'Gym abajo', category: 'fitness', effort: 2, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-01', isArchived: false, repeat: { type: 'weekdays', days: [1, 4] }, repeatBaseId: 'gym-abajo', description: '' },
      { id: 102, title: 'Gym arriba', category: 'fitness', effort: 2, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-01', isArchived: false, repeat: { type: 'weekdays', days: [2, 5] }, repeatBaseId: 'gym-arriba', description: '' },
      { id: 126, title: 'Boxeo switch', category: 'fitness', effort: 2, scheduledDate: null, scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-01', isArchived: false, repeat: { type: 'weekdays', days: [3] }, repeatBaseId: 'boxeo', description: '' },
      { id: 127, title: 'Correr 5km', category: 'fitness', effort: 2, scheduledDate: '2026-02-10', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 212, title: 'Yoga', category: 'fitness', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 213, title: 'Nadar', category: 'fitness', effort: 2, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-18', isArchived: false, repeat: null, description: '' },
      { id: 420, title: 'Comprar proteína', category: 'fitness', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-15', isArchived: false, repeat: null, description: '' },
      { id: 421, title: 'Nuevo plan entrenamiento', category: 'fitness', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-12', isArchived: false, repeat: null, description: '' },
      { id: 422, title: 'Estiramientos mañana', category: 'fitness', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-10', isArchived: false, repeat: null, description: '' },
      { id: 423, title: 'Comprar zapatillas nuevas', category: 'fitness', effort: 1, scheduledDate: null, scheduledSlot: null, completed: false, completedDate: null, createdAt: '2026-01-08', isArchived: false, repeat: null, description: '' },

      // Previous week items (Jan 27 - Feb 1)
      { id: 300, title: 'Reunión equipo', category: 'work', effort: 1, scheduledDate: '2026-01-28', scheduledSlot: 'todo', completed: true, completedDate: '2026-01-28', createdAt: '2026-01-20', isArchived: false, repeat: null, description: '' },
      { id: 301, title: 'Deploy producción', category: 'ai', effort: 2, scheduledDate: '2026-01-29', scheduledSlot: 'todo', completed: true, completedDate: '2026-01-29', createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 302, title: 'Pagar alquiler', category: 'home', effort: 1, scheduledDate: '2026-01-30', scheduledSlot: 'todo', completed: true, completedDate: '2026-01-30', createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 303, title: 'Cena con Ana', category: 'social', effort: 1, scheduledDate: '2026-01-31', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 304, title: 'Comprar regalo', category: 'social', effort: 1, scheduledDate: '2026-02-01', scheduledSlot: 'todo', completed: true, completedDate: '2026-02-01', createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 305, title: 'Backup laptop', category: 'work', effort: 1, scheduledDate: '2026-02-01', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },

      // Additional scheduled items
      { id: 430, title: 'Reunión proyecto X', category: 'work', effort: 2, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 431, title: 'Entregar informe', category: 'work', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },

      // Lunes 2026-02-02 - 10 items normales
      { id: 500, title: 'Revisar emails pendientes', category: 'work', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 501, title: 'Actualizar documentación', category: 'ai', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-30', isArchived: false, repeat: null, description: '' },
      { id: 502, title: 'Llamar banco', category: 'work', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-29', isArchived: false, repeat: null, description: '' },
      { id: 503, title: 'Ordenar escritorio', category: 'home', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-29', isArchived: false, repeat: null, description: '' },
      { id: 504, title: 'Revisar agenda semana', category: 'work', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 505, title: 'Comprar café', category: 'home', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-28', isArchived: false, repeat: null, description: '' },
      { id: 506, title: 'Responder mensajes', category: 'social', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-27', isArchived: false, repeat: null, description: '' },
      { id: 507, title: 'Planificar comidas', category: 'health', effort: 1, scheduledDate: '2026-02-04', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-27', isArchived: false, repeat: null, description: '' },
      // Martes 2026-02-03 - 12 items movidos desde lunes
      { id: 508, title: 'Revisar suscripciones', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-26', isArchived: false, repeat: null, description: '' },
      { id: 509, title: 'Descargar podcast', category: 'entertainment', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-26', isArchived: false, repeat: null, description: '' },
      { id: 510, title: 'Leer artículo productividad', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 511, title: 'Organizar archivos nube', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-25', isArchived: false, repeat: null, description: '' },
      { id: 512, title: 'Reservar restaurante', category: 'social', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-24', isArchived: false, repeat: null, description: '' },
      { id: 513, title: 'Limpiar inbox', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-24', isArchived: false, repeat: null, description: '' },
      { id: 514, title: 'Actualizar apps', category: 'entertainment', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-23', isArchived: false, repeat: null, description: '' },
      { id: 515, title: 'Comprar pan', category: 'home', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-23', isArchived: false, repeat: null, description: '' },
      { id: 516, title: 'Revisar calendario', category: 'work', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-22', isArchived: false, repeat: null, description: '' },
      { id: 517, title: 'Llamar electricista', category: 'home', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-22', isArchived: false, repeat: null, description: '' },
      { id: 518, title: 'Ver tutorial', category: 'ai', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-21', isArchived: false, repeat: null, description: '' },
      { id: 519, title: 'Enviar fotos', category: 'social', effort: 1, scheduledDate: '2026-02-05', scheduledSlot: 'todo', completed: false, completedDate: null, createdAt: '2026-01-21', isArchived: false, repeat: null, description: '' },
    ];

    const initialDayEnergy = { '2026-02-02': 2, '2026-02-03': 3, '2026-02-04': 2, '2026-02-05': 1, '2026-02-06': 2, '2026-02-07': 3, '2026-02-08': 2, '2026-02-09': 2 };
    const REAL_TODAY = new Date('2026-02-06');

    // Global timestamp to track when a popover was just closed
    let lastPopoverCloseTime = 0;

    const formatDate = (d) => {
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };
    const formatDayName = (d) => DAYS[d.getDay()];
    const formatDayNameFull = (d) => DAYS_FULL[d.getDay()];
    const formatDayNumber = (d) => d.getDate();
    const getMonthName = (d) => ['Enero','Febrero','Marzo','Abril','Mayo','Junio','Julio','Agosto','Septiembre','Octubre','Noviembre','Diciembre'][d.getMonth()];
    const getShortMonthName = (d) => MONTHS[d.getMonth()];
    const getEffortColor = (e) => e === 0 ? '#94A3B8' : e === 1 ? '#22C55E' : e === 2 ? '#F59E0B' : '#EF4444';

    const formatDateLabel = (dateStr) => {
      const d = new Date(dateStr + 'T00:00:00');
      return `${formatDayName(d)} ${formatDayNumber(d)} ${getShortMonthName(d)}`;
    };

    const formatRepeatLabel = (repeat) => {
      if (!repeat) return '';
      if (repeat.type === 'days') {
        return repeat.every === 1 ? 'Todos los días' : `Cada ${repeat.every} días`;
      }
      if (repeat.type === 'weeks') {
        return repeat.every === 1 ? 'Cada semana' : `Cada ${repeat.every} semanas`;
      }
      if (repeat.type === 'weekdays' && repeat.days) {
        const dayNames = ['D', 'L', 'M', 'X', 'J', 'V', 'S'];
        const selectedDays = [...repeat.days].sort((a, b) => a - b).map(d => dayNames[d]).join(' ');
        return selectedDays;
      }
      return '';
    };

    // Tooltip text for recurrence icon
    const getRecurrenceTooltip = (repeat) => {
      if (!repeat) return '';
      if (repeat.type === 'days') {
        const modeLabel = repeat.mode === 'completion' ? ' (desde completación)' : '';
        return repeat.every === 1 ? `Cada día${modeLabel}` : `Cada ${repeat.every} días${modeLabel}`;
      }
      if (repeat.type === 'weeks') {
        return repeat.every === 1 ? 'Cada semana' : `Cada ${repeat.every} semanas`;
      }
      if (repeat.type === 'weekdays' && repeat.days) {
        const dayNames = ['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'];
        return [...repeat.days].sort((a, b) => a - b).map(d => dayNames[d]).join(', ');
      }
      return 'Recurrente';
    };

    // === Funciones auxiliares para recurrencia ===
    const getDayDiff = (date1, date2) => {
      const d1 = new Date(date1 + 'T00:00:00');
      const d2 = new Date(date2 + 'T00:00:00');
      return Math.round((d2 - d1) / (1000 * 60 * 60 * 24));
    };

    const shiftDate = (dateStr, days) => {
      const d = new Date(dateStr + 'T00:00:00');
      d.setDate(d.getDate() + days);
      return formatDate(d);
    };

    // Recalcular repeat config cuando se mueve "este y siguientes"
    const recalculateRepeatFromMove = (repeat, origDate, newDate) => {
      if (repeat.type === 'weekdays') {
        const origDay = new Date(origDate + 'T00:00:00').getDay();
        const newDay = new Date(newDate + 'T00:00:00').getDay();
        const newDays = repeat.days.map(d => d === origDay ? newDay : d);
        return { ...repeat, days: [...new Set(newDays)].sort((a, b) => a - b) };
      }
      return { ...repeat };
    };

    // Mover toda la configuración de repeat (para "todos los eventos")
    const shiftRepeatConfig = (repeat, dayOffset) => {
      if (repeat.type === 'weekdays') {
        // Para weekdays, desplazar los días de la semana
        const newDays = repeat.days.map(d => ((d + dayOffset) % 7 + 7) % 7);
        return { ...repeat, days: [...new Set(newDays)].sort((a, b) => a - b) };
      }
      // Para days/weeks, desplazar startDate y endDate
      const newRepeat = { ...repeat };
      if (repeat.startDate) {
        newRepeat.startDate = shiftDate(repeat.startDate, dayOffset);
      }
      if (repeat.endDate) {
        newRepeat.endDate = shiftDate(repeat.endDate, dayOffset);
      }
      return newRepeat;
    };

    // Mover excepciones cuando se mueve toda la serie
    // targetSlot: if provided and not 'done', remove completed state from exceptions
    const shiftExceptions = (exceptions, dayOffset, targetSlot = null) => {
      if (!exceptions) return undefined;
      const newExceptions = {};
      Object.entries(exceptions).forEach(([dateStr, exc]) => {
        const newDateStr = shiftDate(dateStr, dayOffset);
        const newExc = { ...exc };
        if (exc.movedTo) {
          newExc.movedTo = {
            date: shiftDate(exc.movedTo.date, dayOffset),
            slot: exc.movedTo.slot
          };
        }
        if (exc.completedDate) {
          newExc.completedDate = shiftDate(exc.completedDate, dayOffset);
        }
        // If moving to a non-done slot, remove completed state
        if (targetSlot && targetSlot !== 'done' && newExc.completed) {
          delete newExc.completed;
          delete newExc.completedDate;
        }
        // Only add exception if it still has properties
        if (Object.keys(newExc).length > 0) {
          newExceptions[newDateStr] = newExc;
        }
      });
      return Object.keys(newExceptions).length > 0 ? newExceptions : undefined;
    };

    // Get valid move range for a recurring instance (Outlook model: can't skip over other instances)
    // Returns { minDate, maxDate } - the instance can only be moved within this range
    const getValidMoveRange = (item, instanceDate) => {
      if (!item.repeat) return { minDate: null, maxDate: null };

      const todayStr = formatDate(REAL_TODAY);
      const instanceDateObj = new Date(instanceDate + 'T00:00:00');

      // Helper to check if a date matches the repeat pattern
      const isValidRepeatDate = (dateStr) => {
        const dateObj = new Date(dateStr + 'T00:00:00');

        // Check startDate/endDate bounds
        if (item.repeat.startDate && dateStr < item.repeat.startDate) return false;
        if (item.repeat.endDate && dateStr > item.repeat.endDate) return false;

        // Check if deleted or moved (skip these)
        const exc = item.exceptions?.[dateStr];
        if (exc?.deleted || exc?.movedTo) return false;

        if (item.repeat.type === 'weekdays') {
          return item.repeat.days.includes(dateObj.getDay());
        } else if (item.repeat.type === 'days') {
          const baseDateStr = item.repeat.startDate || item.createdAt;
          const baseDate = new Date(baseDateStr + 'T00:00:00');
          const daysSinceBase = Math.round((dateObj - baseDate) / (1000 * 60 * 60 * 24));
          return daysSinceBase >= 0 && daysSinceBase % item.repeat.every === 0;
        } else if (item.repeat.type === 'weeks') {
          const baseDateStr = item.repeat.startDate || item.createdAt;
          const baseDate = new Date(baseDateStr + 'T00:00:00');
          const daysSinceBase = Math.round((dateObj - baseDate) / (1000 * 60 * 60 * 24));
          const weeksSinceBase = Math.floor(daysSinceBase / 7);
          return daysSinceBase >= 0 && dateObj.getDay() === baseDate.getDay() && weeksSinceBase % item.repeat.every === 0;
        }
        return false;
      };

      // Find previous instance (searching backwards from instanceDate)
      let prevDate = null;
      let checkDate = new Date(instanceDateObj);
      checkDate.setDate(checkDate.getDate() - 1);
      for (let i = 0; i < 365; i++) { // Search up to 1 year back
        const checkStr = formatDate(checkDate);
        if (isValidRepeatDate(checkStr)) {
          prevDate = checkStr;
          break;
        }
        checkDate.setDate(checkDate.getDate() - 1);
      }

      // Find next instance (searching forwards from instanceDate)
      let nextDate = null;
      checkDate = new Date(instanceDateObj);
      checkDate.setDate(checkDate.getDate() + 1);
      for (let i = 0; i < 365; i++) { // Search up to 1 year forward
        const checkStr = formatDate(checkDate);
        if (isValidRepeatDate(checkStr)) {
          nextDate = checkStr;
          break;
        }
        checkDate.setDate(checkDate.getDate() + 1);
      }

      // Calculate valid range
      // minDate: day after previous instance, but not before today
      let minDate = prevDate ? shiftDate(prevDate, 1) : null;
      if (minDate && minDate < todayStr) minDate = todayStr;
      if (!minDate) minDate = todayStr; // If no previous instance, min is today

      // maxDate: day before next instance (or null if no next instance = can go anywhere in future)
      let maxDate = nextDate ? shiftDate(nextDate, -1) : null;

      return { minDate, maxDate };
    };

    // Find next valid date for a repeat pattern (for creating items on invalid days)
    const findNextValidDate = (fromDate, repeat) => {
      if (!repeat || repeat.type !== 'weekdays') return fromDate;
      if (!repeat.days || repeat.days.length === 0) return fromDate;

      const startDate = new Date(fromDate + 'T00:00:00');
      let checkDate = new Date(startDate);

      // Check if current date is already valid
      if (repeat.days.includes(checkDate.getDay())) {
        return fromDate;
      }

      // Search up to 7 days for the next valid date
      for (let i = 1; i <= 7; i++) {
        checkDate.setDate(checkDate.getDate() + 1);
        if (repeat.days.includes(checkDate.getDay())) {
          return formatDate(checkDate);
        }
      }

      return fromDate; // Fallback
    };

    const getEffortBarColor = (effort, max) => {
      if (effort === 0) return 'var(--border-color)';
      const ratio = effort / max;
      if (effort > max) return '#EF4444';
      if (ratio >= 1) return '#F59E0B';
      if (ratio >= 0.6) return '#22C55E';
      return '#3B82F6';
    };

    const getEffortBarWidth = (effort, max) => {
      if (effort === 0) return 0;
      const ratio = effort / max;
      if (ratio <= 0.33) return 25;
      if (ratio <= 0.66) return 50;
      if (ratio <= 1) return 75;
      return 100;
    };

    const MOBILE_PAST_DAYS = 14;

    const getDaysArray = (base, pastDays = 1) => {
      const days = [];
      for (let i = pastDays; i >= 1; i--) {
        const day = new Date(base); day.setDate(day.getDate() - i);
        days.push({ date: day, isPast: day < REAL_TODAY });
      }
      for (let i = 0; i < 31; i++) {
        const day = new Date(base); day.setDate(day.getDate() + i);
        days.push({ date: day, isPast: day < REAL_TODAY });
      }
      return days;
    };

    const generateRecurringInstances = (baseItems, startDate, endDate) => {
      const instances = [];
      const recurringItems = baseItems.filter(i => i.repeat);
      const nonRecurringItems = baseItems.filter(i => !i.repeat);

      recurringItems.forEach(item => {
        let currentDate = new Date(startDate);
        // Soportar endDate en la serie (para "este y siguientes")
        const repeatEndDate = item.repeat.endDate ? new Date(item.repeat.endDate + 'T00:00:00') : endDate;
        const effectiveEndDate = repeatEndDate < endDate ? repeatEndDate : endDate;

        while (currentDate <= effectiveEndDate) {
          const dateStr = formatDate(currentDate);

          // Verificar excepciones
          const exception = item.exceptions?.[dateStr];

          // Si está eliminada, saltar
          if (exception?.deleted) {
            currentDate.setDate(currentDate.getDate() + 1);
            continue;
          }

          // Si está movida a otra fecha, no generar aquí (se genera abajo)
          if (exception?.movedTo) {
            console.log('Skipping', dateStr, 'for item', item.id, '- moved to', exception.movedTo.date);
            currentDate.setDate(currentDate.getDate() + 1);
            continue;
          }

          let shouldAdd = false;

          // Verificar startDate de la serie (para "este y siguientes")
          // Usamos comparación de strings (YYYY-MM-DD) para evitar problemas de timezone
          const repeatStartDateStr = item.repeat.startDate || null;
          if (repeatStartDateStr && dateStr < repeatStartDateStr) {
            currentDate.setDate(currentDate.getDate() + 1);
            continue;
          }

          // Si es exactamente el startDate, forzar que aparezca (primera instancia de "este y siguientes")
          const isExactStartDate = repeatStartDateStr && dateStr === repeatStartDateStr;

          if (item.repeat.type === 'days') {
            // Check if completion-based mode
            if (item.repeat.mode === 'completion') {
              // Find the last completed date from exceptions
              let lastCompletedDate = null;
              if (item.exceptions) {
                Object.entries(item.exceptions).forEach(([excDate, exc]) => {
                  if (exc.completed && exc.completedDate) {
                    if (!lastCompletedDate || exc.completedDate > lastCompletedDate) {
                      lastCompletedDate = exc.completedDate;
                    }
                  }
                });
              }

              if (lastCompletedDate) {
                // Calculate from last completion date
                const baseDate = new Date(lastCompletedDate + 'T00:00:00');
                const currentNormalized = new Date(dateStr + 'T00:00:00');
                const daysSinceCompletion = Math.round((currentNormalized - baseDate) / (1000 * 60 * 60 * 24));
                // Show instance at exactly N days after completion
                shouldAdd = daysSinceCompletion > 0 && daysSinceCompletion % item.repeat.every === 0;
              } else {
                // No completions yet - use original base date
                const baseDateStr = item.repeat.startDate || item.createdAt;
                const baseDate = new Date(baseDateStr + 'T00:00:00');
                const currentNormalized = new Date(dateStr + 'T00:00:00');
                const daysSinceBase = Math.round((currentNormalized - baseDate) / (1000 * 60 * 60 * 24));
                shouldAdd = daysSinceBase >= 0 && daysSinceBase % item.repeat.every === 0;
              }
            } else {
              // Fixed mode (default) - Use startDate as base if available, otherwise use createdAt
              const baseDateStr = item.repeat.startDate || item.createdAt;
              const baseDate = new Date(baseDateStr + 'T00:00:00');
              const currentNormalized = new Date(dateStr + 'T00:00:00');
              const daysSinceBase = Math.round((currentNormalized - baseDate) / (1000 * 60 * 60 * 24));
              shouldAdd = daysSinceBase >= 0 && daysSinceBase % item.repeat.every === 0;
            }
          } else if (item.repeat.type === 'weeks') {
            // Use startDate as base if available (for "este y los siguientes"), otherwise use createdAt
            const baseDateStr = item.repeat.startDate || item.createdAt;
            const baseDate = new Date(baseDateStr + 'T00:00:00');
            const currentNormalized = new Date(dateStr + 'T00:00:00');
            const daysSinceBase = Math.round((currentNormalized - baseDate) / (1000 * 60 * 60 * 24));
            const weeksSinceBase = Math.floor(daysSinceBase / 7);
            const dayOfWeek = baseDate.getDay();
            shouldAdd = daysSinceBase >= 0 && currentNormalized.getDay() === dayOfWeek && weeksSinceBase % item.repeat.every === 0;
          } else if (item.repeat.type === 'weekdays') {
            shouldAdd = item.repeat.days.includes(currentDate.getDay());
          }

          // Si es exactamente el startDate, mostrar solo si también cumple las reglas de recurrencia
          // (para weekdays, el startDate debe caer en un día válido)
          if (isExactStartDate && !shouldAdd) {
            // Solo forzar para tipos que no dependen del día de semana
            if (item.repeat.type === 'days') {
              shouldAdd = true;
            }
            // Para weekdays/weeks, el startDate ya debe cumplir las reglas (no forzar)
          }

          if (shouldAdd) {
            const dateOverride = item.dateOverrides?.[dateStr] || {};
            // Check if this instance is marked as completed via exception
            const isCompleted = exception?.completed || false;
            const completedDate = exception?.completedDate || null;
            // Apply property overrides from exception (title, description, effort)
            const propertyOverrides = {};
            if (exception?.title !== undefined) propertyOverrides.title = exception.title;
            if (exception?.description !== undefined) propertyOverrides.description = exception.description;
            if (exception?.effort !== undefined) propertyOverrides.effort = exception.effort;
            // Check if this is an overdue recurring item (past date, not completed)
            const todayStr = formatDate(REAL_TODAY);
            const isOverdue = dateStr < todayStr && !isCompleted;
            instances.push({
              ...item,
              ...propertyOverrides,
              id: `${item.id}-${dateStr}`,
              scheduledDate: dateStr,
              originalId: item.id,
              sortOrder: dateOverride.sortOrder ?? item.sortOrder ?? 0,
              completed: isCompleted,
              completedDate: completedDate,
              _isOverdue: isOverdue,
            });
          }

          currentDate.setDate(currentDate.getDate() + 1);
        }

        // Generar instancias movidas (excepciones con movedTo)
        if (item.exceptions) {
          Object.entries(item.exceptions).forEach(([origDate, exc]) => {
            if (exc.movedTo) {
              const movedDate = new Date(exc.movedTo.date + 'T00:00:00');
              if (movedDate >= startDate && movedDate <= endDate) {
                const dateOverride = item.dateOverrides?.[exc.movedTo.date] || {};
                // Check if this moved instance is marked as completed
                const isCompleted = exc.completed || false;
                const completedDate = exc.completedDate || null;
                // Apply property overrides from exception (title, description, effort)
                const propertyOverrides = {};
                if (exc.title !== undefined) propertyOverrides.title = exc.title;
                if (exc.description !== undefined) propertyOverrides.description = exc.description;
                if (exc.effort !== undefined) propertyOverrides.effort = exc.effort;
                // Check if this moved instance is overdue
                const todayStr = formatDate(REAL_TODAY);
                const isOverdue = exc.movedTo.date < todayStr && !isCompleted;
                instances.push({
                  ...item,
                  ...propertyOverrides,
                  id: `${item.id}-${origDate}-moved`,
                  scheduledDate: exc.movedTo.date,
                  scheduledSlot: exc.movedTo.slot || item.scheduledSlot,
                  originalId: item.id,
                  originalScheduledDate: origDate,
                  sortOrder: dateOverride.sortOrder ?? item.sortOrder ?? 0,
                  completed: isCompleted,
                  completedDate: completedDate,
                  _isMoved: true,
                  _isOverdue: isOverdue,
                });
              }
            }
          });
        }
      });

      return [...nonRecurringItems, ...instances];
    };

    // ============ COMPONENTS ============
    const EffortBar = ({ effort, maxEffort = 3, isToday = false }) => {
      // Colors match effort selector: 0=gray, 1=green, 2=orange, 3=red
      const color = effort === 0 ? '#94A3B8'
        : effort === 1 ? (isToday ? '#16A34A' : '#22C55E')
        : effort === 2 ? (isToday ? '#D97706' : '#F59E0B')
        : (isToday ? '#DC2626' : '#EF4444');
      const width = effort === 0 ? 0 : effort === 1 ? 33 : effort === 2 ? 66 : 100;
      // Darker background for today - more visible against white/light card
      const bgColor = isToday ? 'var(--effort-bg-today)' : 'var(--border-color)';

      return (
        <div className="effort-bar" style={{ background: bgColor }}>
          <div className="effort-bar-fill" style={{ width: `${width}%`, background: color }} />
        </div>
      );
    };

    const EffortBarSlot = ({ effort, energy }) => {
      const max = energy === 1 ? 4 : energy === 2 ? 7 : 10;
      const color = getEffortBarColor(effort, max);
      const width = getEffortBarWidth(effort, max);

      return (
        <div className="effort-bar">
          <div className="effort-bar-fill" style={{ width: `${width}%`, background: color }} />
        </div>
      );
    };

    const EnergySelector = ({ energy, onChange }) => (
      <div style={{ display: 'flex', gap: '4px' }}>
        {[1,2,3].map(l => (
          <button key={l} onClick={(e) => { e.stopPropagation(); onChange(l); }} style={{
            background: 'none',
            border: 'none',
            padding: '0',
            fontSize: '0.75rem',
            cursor: 'pointer',
            opacity: energy === l ? 1 : 0.3,
            filter: energy === l ? 'none' : 'grayscale(100%)',
          }}>{l === 1 ? '❤️‍🩹' : l === 2 ? '❤️' : '❤️‍🔥'}</button>
        ))}
      </div>
    );

    // Robust popover that calculates position after render
    const Popover = ({ children, onClose, onRequestClose, targetRect }) => {
      const ref = useRef(null);
      const [pos, setPos] = useState(null);

      // Use onRequestClose if provided, otherwise use onClose directly
      const handleCloseAttempt = useCallback(() => {
        if (onRequestClose) {
          onRequestClose();
        } else {
          lastPopoverCloseTime = Date.now();
          onClose();
        }
      }, [onClose, onRequestClose]);

      // Calculate position after mount
      useEffect(() => {
        if (!targetRect || !ref.current) return;

        // Use requestAnimationFrame to ensure DOM is painted
        const raf = requestAnimationFrame(() => {
          if (!ref.current) return;

          const popW = ref.current.offsetWidth;
          const popH = ref.current.offsetHeight;

          // Calculate position below the target
          let top = targetRect.bottom + 6;
          let left = targetRect.left;

          // Adjust if would go off bottom of screen
          if (top + popH > window.innerHeight - 10) {
            top = targetRect.top - popH - 6;
          }

          // Adjust if would go off right of screen
          if (left + popW > window.innerWidth - 10) {
            left = window.innerWidth - popW - 10;
          }

          // Ensure minimum margins
          left = Math.max(10, left);
          top = Math.max(10, top);

          setPos({ top, left });
        });

        return () => cancelAnimationFrame(raf);
      }, [targetRect]);

      // Close on click outside
      useEffect(() => {
        const handler = (e) => {
          if (ref.current && !ref.current.contains(e.target)) {
            handleCloseAttempt();
          }
        };
        // Delay to avoid immediate close from the click that opened it
        const timer = setTimeout(() => {
          document.addEventListener('mousedown', handler);
        }, 10);
        return () => {
          clearTimeout(timer);
          document.removeEventListener('mousedown', handler);
        };
      }, [handleCloseAttempt]);

      // Close on Escape key
      useEffect(() => {
        const handler = (e) => {
          if (e.key === 'Escape') {
            handleCloseAttempt();
          }
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [handleCloseAttempt]);

      return (
        <div
          ref={ref}
          className={`popover ${pos ? 'ready' : ''}`}
          style={{
            top: pos ? pos.top : -9999,
            left: pos ? pos.left : -9999,
            opacity: pos ? 1 : 0,
            visibility: pos ? 'visible' : 'hidden',
          }}
        >
          {children}
        </div>
      );
    };

    const DiscardConfirmDialog = ({ onDiscard, onContinue }) => {
      useEffect(() => {
        const handler = (e) => {
          if (e.key === 'Escape') {
            onContinue();
          }
        };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [onContinue]);

      return ReactDOM.createPortal(
        <>
          <div className="discard-overlay" onClick={onContinue} />
          <div className="discard-dialog">
            <div className="dialog-title">
              ¿Descartar cambios?
            </div>
            <div className="dialog-text">
              Tienes cambios sin guardar. ¿Qué deseas hacer?
            </div>
            <div className="popover-actions">
              <button className="btn btn-submit" onClick={onContinue}>
                Seguir editando
              </button>
              <button className="btn btn-danger btn-submit" onClick={onDiscard}>
                Descartar
              </button>
            </div>
          </div>
        </>,
        document.body
      );
    };

    const DropZone = ({ onDrop, children, style = {}, onDragEnter, onDragEnd, className = '' }) => {
      const [over, setOver] = useState(false);
      return (
        <div className={`drop-zone ${over ? 'drag-over' : ''} ${className}`}
          onDragOver={(e) => {
            // Only show drop indicator for item drags, not category drags
            if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
              e.preventDefault();
              setOver(true);
            }
          }}
          onDragEnter={(e) => {
            if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
              setOver(true);
              onDragEnter?.();
            }
          }}
          onDragLeave={() => { setOver(false); }}
          onDrop={(e) => { e.preventDefault(); setOver(false); onDragEnd?.(); const data = e.dataTransfer.getData('itemData'); if (data) onDrop(JSON.parse(data), e); }}
          style={style}
        >{children}</div>
      );
    };

    const Toast = ({ message, onUndo, onClose, duration = 10000 }) => {
      useEffect(() => {
        const timer = setTimeout(onClose, duration);
        return () => clearTimeout(timer);
      }, [onClose, duration]);

      return (
        <div className="toast">
          <span className="toast-message">{message}</span>
          <button onClick={onUndo} className="btn toast-undo">Deshacer</button>
        </div>
      );
    };

    // Mini calendar for date picking
    const MiniCalendar = ({ selectedDate, onSelect, onClose, validDateRange }) => {
      const [viewMonth, setViewMonth] = useState(() => {
        if (selectedDate) return new Date(selectedDate + 'T00:00:00');
        return new Date(REAL_TODAY);
      });

      const getDaysInMonth = (date) => {
        const year = date.getFullYear();
        const month = date.getMonth();
        const firstDay = new Date(year, month, 1);
        const lastDay = new Date(year, month + 1, 0);
        const days = [];

        // Add empty slots for days before first of month
        for (let i = 0; i < firstDay.getDay(); i++) {
          days.push(null);
        }
        // Add all days of month
        for (let d = 1; d <= lastDay.getDate(); d++) {
          days.push(new Date(year, month, d));
        }
        return days;
      };

      const days = getDaysInMonth(viewMonth);
      const monthName = viewMonth.toLocaleDateString('es', { month: 'long', year: 'numeric' });

      return (
        <div className="mini-calendar">
          <div className="mini-calendar-header">
            <button type="button" onClick={() => setViewMonth(new Date(viewMonth.getFullYear(), viewMonth.getMonth() - 1, 1))} className="btn" style={{ padding: '2px 6px' }}>◀</button>
            <span className="mini-calendar-month">{monthName}</span>
            <button type="button" onClick={() => setViewMonth(new Date(viewMonth.getFullYear(), viewMonth.getMonth() + 1, 1))} className="btn" style={{ padding: '2px 6px' }}>▶</button>
          </div>
          <div className="mini-calendar-grid">
            {['D', 'L', 'M', 'M', 'J', 'V', 'S'].map((d, i) => (
              <div key={i} className="mini-calendar-day-label">{d}</div>
            ))}
            {days.map((day, i) => {
              if (!day) return <div key={i} />;
              const dateStr = formatDate(day);
              const isSelected = dateStr === selectedDate;
              const isToday = dateStr === formatDate(REAL_TODAY);
              const isDisabled = validDateRange && (
                (validDateRange.minDate && dateStr < validDateRange.minDate) ||
                (validDateRange.maxDate && dateStr > validDateRange.maxDate)
              );
              return (
                <button
                  key={i}
                  type="button"
                  onClick={isDisabled ? undefined : () => { onSelect(dateStr); onClose(); }}
                  disabled={isDisabled}
                  style={{
                    padding: '4px', border: 'none', borderRadius: '4px',
                    cursor: isDisabled ? 'default' : 'pointer',
                    background: isSelected ? 'var(--accent-blue)' : isToday ? 'var(--today-header)' : 'transparent',
                    color: isDisabled ? 'var(--text-muted)' : isSelected ? '#FFF' : 'var(--text-primary)',
                    fontSize: '0.625rem', fontWeight: isToday ? '700' : '400',
                    opacity: isDisabled ? 0.3 : 1,
                  }}
                >
                  {day.getDate()}
                </button>
              );
            })}
          </div>
          <button type="button" onClick={() => { onSelect(null); onClose(); }} className="btn" style={{ width: '100%', fontSize: '0.625rem' }}>

            Sin fecha
          </button>
        </div>
      );
    };

    const AddEditItemPopover = ({ categories, onSave, onDelete, onComplete, onClose, onDuplicate, targetRect, editItem, defaultCategory, defaultSlot, defaultDate, addCompleted, visualDate }) => {
      const [title, setTitle] = useState(editItem?.title || '');
      const [description, setDescription] = useState(editItem?.description || '');
      const [category, setCategory] = useState(editItem?.category || defaultCategory || 'temp');
      const [effort, setEffort] = useState(editItem?.effort ?? 1);
      // For recurring items, use visualDate as initial scheduled date
      const initialDate = editItem?.scheduledDate || visualDate || defaultDate || null;
      const [scheduledDate, setScheduledDate] = useState(initialDate);
      const [scheduledSlot, setScheduledSlot] = useState(editItem?.scheduledSlot || defaultSlot || 'todo');
      const [userClearedDate, setUserClearedDate] = useState(false); // Track if user explicitly chose "Sin fecha"
      const [repeatType, setRepeatType] = useState(editItem?.repeat?.type || 'none');
      const [repeatEvery, setRepeatEvery] = useState(editItem?.repeat?.every || 1);
      const [repeatDays, setRepeatDays] = useState(editItem?.repeat?.days || []);
      const [repeatMode, setRepeatMode] = useState(editItem?.repeat?.mode || 'fixed');
      const [showDatePicker, setShowDatePicker] = useState(false);
      const [showDiscardDialog, setShowDiscardDialog] = useState(false);
      const dateButtonRef = useRef(null);
      const inputRef = useRef(null);

      const isEditing = !!editItem?.id && !editItem._isNewItem;
      const hadRepeat = !!editItem?.repeat;

      // Compute valid date range for recurring items (Outlook restriction)
      const validDateRange = useMemo(() => {
        if (!editItem?.repeat || !visualDate) return null;
        return getValidMoveRange(editItem, visualDate);
      }, [editItem, visualDate]);
      const originalTitle = editItem?.title || '';
      const originalDescription = editItem?.description || '';
      const originalCategory = editItem?.category || defaultCategory || 'temp';
      const originalEffort = editItem?.effort ?? 1;
      // For recurring items, use the same initialDate logic to compare against
      const originalScheduledDate = editItem?.scheduledDate || visualDate || defaultDate || null;
      const originalScheduledSlot = editItem?.scheduledSlot || defaultSlot || 'todo';
      const originalRepeatType = editItem?.repeat?.type || 'none';
      const originalRepeatEvery = editItem?.repeat?.every || 1;
      const originalRepeatDays = editItem?.repeat?.days || [];
      const originalRepeatMode = editItem?.repeat?.mode || 'fixed';

      // Helper to compare arrays (with numeric sort for day numbers)
      const arraysEqual = (a, b) => {
        if (a.length !== b.length) return false;
        const sortedA = [...a].sort((x, y) => x - y);
        const sortedB = [...b].sort((x, y) => x - y);
        return sortedA.every((v, i) => v === sortedB[i]);
      };

      // Check if this is a new item created with empty title (using _isNewItem marker)
      // Note: _isNewItem items are NOT considered "editing", so check separately
      const isNewUntitledItem = !!editItem?._isNewItem || (!!editItem?.id && originalTitle === '');

      // For new untitled items, check if user has made ANY changes from default state
      const hasUserChanges = isNewUntitledItem ? (
        title.trim() !== '' ||
        description !== '' ||
        category !== originalCategory ||
        effort !== 1 ||
        repeatType !== 'none'
      ) : (
        isEditing ? (
          title !== originalTitle ||
          description !== originalDescription ||
          category !== originalCategory ||
          effort !== originalEffort ||
          scheduledDate !== originalScheduledDate ||
          scheduledSlot !== originalScheduledSlot ||
          repeatType !== originalRepeatType ||
          repeatEvery !== originalRepeatEvery ||
          repeatMode !== originalRepeatMode ||
          !arraysEqual(repeatDays, originalRepeatDays)
        ) : title.trim().length > 0
      );

      const hasChanges = isEditing ? (
        title !== originalTitle ||
        description !== originalDescription ||
        category !== originalCategory ||
        effort !== originalEffort ||
        scheduledDate !== originalScheduledDate ||
        scheduledSlot !== originalScheduledSlot ||
        repeatType !== originalRepeatType ||
        repeatEvery !== originalRepeatEvery ||
        repeatMode !== originalRepeatMode ||
        !arraysEqual(repeatDays, originalRepeatDays)
      ) : title.trim().length > 0;

      // Handle close attempt - show confirmation if there are user changes
      const handleRequestClose = useCallback(() => {
        if (hasUserChanges) {
          // Show confirmation dialog
          setShowDiscardDialog(true);
        } else {
          // No user changes - close directly
          // If it's a new untitled item with no changes, delete it
          if (isNewUntitledItem) {
            onDelete(editItem.id);
          }
          lastPopoverCloseTime = Date.now();
          onClose();
        }
      }, [hasUserChanges, isNewUntitledItem, editItem, onDelete, onClose]);

      const handleDiscard = () => {
        setShowDiscardDialog(false);
        // If it's a new untitled item, delete it
        if (isNewUntitledItem) {
          onDelete(editItem.id);
        }
        lastPopoverCloseTime = Date.now();
        onClose();
      };

      const handleContinueEditing = () => {
        setShowDiscardDialog(false);
      };

      useEffect(() => { setTimeout(() => inputRef.current?.focus(), 50); }, []);

      // Hotkey: Command+E to delete item (desktop only)
      useEffect(() => {
        if (!isEditing) return;
        const handleKeyDown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
            e.preventDefault();
            onDelete(editItem.id);
            lastPopoverCloseTime = Date.now();
            onClose();
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [isEditing, editItem, onDelete, onClose]);

      const toggleDay = (d) => setRepeatDays(p => p.includes(d) ? p.filter(x => x !== d) : [...p, d]);

      const handleSubmit = (e) => {
        e.preventDefault();
        if (!title.trim() || (isEditing && !hasChanges)) return;
        let repeat = null;
        if (repeatType === 'weekdays') repeat = { type: 'weekdays', days: repeatDays };
        else if (repeatType !== 'none') repeat = { type: repeatType, every: repeatEvery, mode: repeatMode };

        // When removing repeat from an item, use visualDate as the scheduled date
        // BUT only if user didn't explicitly clear the date
        let finalScheduledDate = scheduledDate;
        if (hadRepeat && !repeat && !scheduledDate && visualDate && !userClearedDate) {
          finalScheduledDate = visualDate;
        }

        onSave({
          id: editItem?.id, title, description, category, effort, repeat,
          scheduledDate: finalScheduledDate,
          scheduledSlot: (finalScheduledDate || repeat) ? scheduledSlot : null,
          completed: addCompleted || editItem?.completed,
          completedDate: addCompleted ? defaultDate : editItem?.completedDate,
          isArchived: false, // Items go to backlog, not archived
          dateOverrides: repeat ? editItem?.dateOverrides : undefined, // Clear dateOverrides if no longer recurring
        });
        onClose();
      };

      const getDateLabel = () => {
        if (!scheduledDate) return 'Sin fecha';
        return formatDateLabel(scheduledDate);
      };

      return (
        <>
          <Popover onClose={onClose} onRequestClose={handleRequestClose} targetRect={targetRect}>
            <form onSubmit={handleSubmit}>
              <input ref={inputRef} value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Item..."
                className="form-control form-control-md form-group"
              />
              <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Descripción..." rows={2}
                className="form-control form-control-sm form-group form-textarea"
              />
              <select value={category} onChange={(e) => setCategory(e.target.value)} className="form-control form-control-sm form-group">
                {categories.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
              </select>

              <div className="form-group-rel">
                <div className="form-label">Fecha</div>
                <button
                  ref={dateButtonRef}
                  type="button"
                  onClick={() => setShowDatePicker(!showDatePicker)}
                  className="form-control form-control-sm"
                  style={{
                    padding: '6px 8px',
                    color: scheduledDate ? 'var(--text-primary)' : 'var(--text-muted)',
                    textAlign: 'left', cursor: 'pointer',
                  }}
                >
                  {getDateLabel()}
                </button>
                {showDatePicker && (
                  <div style={{ position: 'absolute', top: '100%', left: 0, right: 0, zIndex: 100, marginTop: '4px' }}>
                    <MiniCalendar selectedDate={scheduledDate} onSelect={(date) => { setScheduledDate(date); if (!date) { setRepeatType('none'); setUserClearedDate(true); } }} onClose={() => setShowDatePicker(false)} validDateRange={validDateRange} />
                  </div>
                )}
              </div>

              {hadRepeat && userClearedDate && (
                <div className="warning-box form-group">
                  Al guardar se eliminará la recurrencia
                </div>
              )}

              {/* Only show repeat options if there's a date */}
              {scheduledDate && (
                <div className="form-group-lg">
                  <select value={repeatType} onChange={(e) => setRepeatType(e.target.value)} className="form-control" style={{ padding: '6px', fontSize: '0.625rem' }}>
                    <option value="none">No repetir</option>
                    <option value="days">Cada X días</option>
                    <option value="weeks">Cada X semanas</option>
                    <option value="weekdays">Días de semana</option>
                  </select>
                  {repeatType !== 'none' && repeatType !== 'weekdays' && (
                    <>
                      <input type="number" min="1" max="30" value={repeatEvery} onChange={(e) => setRepeatEvery(parseInt(e.target.value) || 1)}
                        className="form-control form-control-sm" style={{ marginTop: '4px', textAlign: 'center' }}
                      />
                      {repeatType === 'days' && (
                        <select value={repeatMode} onChange={(e) => setRepeatMode(e.target.value)} className="form-control" style={{ marginTop: '4px', padding: '6px', fontSize: '0.5625rem', color: 'var(--text-muted)' }}>
                          <option value="fixed">Desde fecha fija</option>
                          <option value="completion">Desde última completación</option>
                        </select>
                      )}
                    </>
                  )}
                  {repeatType === 'weekdays' && (
                    <div style={{ display: 'flex', gap: '2px', marginTop: '4px' }}>
                      {DAYS.map((d, i) => (
                        <button key={i} type="button" onClick={() => toggleDay(i)} className={repeatDays.includes(i) ? 'btn btn-primary' : 'btn'} style={{ flex: 1, padding: '4px 2px', fontSize: '0.5625rem' }}>{d.charAt(0)}</button>
                      ))}
                    </div>
                  )}
                </div>
              )}

              <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
                {isEditing && <button type="button" onClick={() => { onDelete(editItem.id); onClose(); }} className="btn-icon-danger"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>}
                {isEditing && onDuplicate && <button type="button" onClick={() => { onDuplicate(editItem.id); onClose(); }} className="btn" style={{ padding: '6px 8px', background: 'var(--bg-button)' }} title="Duplicar"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button>}
                <button type="submit" className="btn btn-primary btn-submit" disabled={!hasChanges && isEditing}>{isEditing ? 'Guardar' : 'Agregar'}</button>
              </div>
            </form>
          </Popover>
          {showDiscardDialog && <DiscardConfirmDialog onDiscard={handleDiscard} onContinue={handleContinueEditing} />}
        </>
      );
    };

    const EditCategoryPopover = ({ category, itemCount, onSave, onDelete, onClose, targetRect }) => {
      const [name, setName] = useState(category?.name || '');
      const [color, setColor] = useState(category?.color || COLORS[0]);
      const [showDiscardDialog, setShowDiscardDialog] = useState(false);
      const inputRef = useRef(null);
      const canDelete = itemCount === 0;
      const isNew = !category?.id;

      useEffect(() => { setTimeout(() => inputRef.current?.focus(), 50); }, []);

      const originalName = category?.name || '';
      const originalColor = category?.color || COLORS[0];
      const hasChanges = isNew ? name.trim().length > 0 : (name !== originalName || color !== originalColor);

      const handleRequestClose = () => {
        if (hasChanges) {
          setShowDiscardDialog(true);
        } else {
          lastPopoverCloseTime = Date.now();
          onClose();
        }
      };

      const handleDiscard = () => {
        setShowDiscardDialog(false);
        lastPopoverCloseTime = Date.now();
        onClose();
      };

      const handleContinueEditing = () => {
        setShowDiscardDialog(false);
      };

      return (
        <>
          <Popover onClose={handleRequestClose} targetRect={targetRect}>
            <div className="form-group">
              <div className="form-label">Nombre</div>
              <input ref={inputRef} value={name} onChange={(e) => setName(e.target.value)} placeholder="Categoría..."
                className="form-control form-control-sm" style={{ padding: '8px' }}
              />
            </div>
            <div className="form-group-lg">
              <div className="form-label">Color</div>
              <div style={{ display: 'flex', gap: '4px', flexWrap: 'wrap' }}>
                {COLORS.map(c => (
                  <button key={c} type="button" onClick={() => setColor(c)} style={{
                    width: '22px', height: '22px', borderRadius: '4px', cursor: 'pointer', border: 'none', outline: color === c ? '2px solid var(--text-primary)' : 'none', outlineOffset: '1px', background: c,
                  }} />
                ))}
              </div>
            </div>
            <div style={{ display: 'flex', gap: '6px', alignItems: 'center' }}>
              {!isNew && <button onClick={() => canDelete && onDelete(category.id)} disabled={!canDelete} className={canDelete ? 'btn-icon-danger' : 'btn'} style={{ padding: '6px 8px' }} title={!canDelete ? `${itemCount} items` : ''}><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>}
              <button onClick={() => { if (name.trim() && hasChanges) { onSave({ ...category, id: category?.id || `cat_${Date.now()}`, name: name.trim(), color }); onClose(); }}} className="btn btn-primary btn-submit" disabled={!hasChanges}>Guardar</button>
            </div>
            {!isNew && !canDelete && <div style={{ fontSize: '0.5625rem', color: 'var(--text-muted)', marginTop: '4px' }}>Tiene {itemCount} items</div>}
          </Popover>
          {showDiscardDialog && <DiscardConfirmDialog onDiscard={handleDiscard} onContinue={handleContinueEditing} />}
        </>
      );
    };

    // ============ CATEGORIES MODAL ============
    const CategoriesModal = ({ categories, items, onSave, onDelete, onReorder, onClose }) => {
      const [localCategories, setLocalCategories] = useState(
        categories.filter(c => !c.isFixed).map(c => ({ ...c }))
      );
      const [draggedIndex, setDraggedIndex] = useState(null);
      const [colorPickerIndex, setColorPickerIndex] = useState(null);
      const newCatInputRef = useRef(null);
      const [newCatIndex, setNewCatIndex] = useState(null);

      // Close on Escape
      useEffect(() => {
        const handler = (e) => { if (e.key === 'Escape') onClose(); };
        document.addEventListener('keydown', handler);
        return () => document.removeEventListener('keydown', handler);
      }, [onClose]);

      const getItemCount = (catId) => items.filter(i => i.category === catId).length;

      const handleColorChange = (index, newColor) => {
        setLocalCategories(prev => {
          const updated = [...prev];
          updated[index] = { ...updated[index], color: newColor };
          return updated;
        });
        setColorPickerIndex(null);
      };

      const handleNameChange = (index, newName) => {
        setLocalCategories(prev => {
          const updated = [...prev];
          updated[index] = { ...updated[index], name: newName };
          return updated;
        });
      };

      const handleAddCategory = () => {
        const newCat = {
          id: `cat_${Date.now()}`,
          name: '',
          color: COLORS[localCategories.length % COLORS.length],
        };
        setLocalCategories(prev => [...prev, newCat]);
        setNewCatIndex(localCategories.length);
      };

      // Focus new category input after render
      useEffect(() => {
        if (newCatIndex !== null && newCatInputRef.current) {
          newCatInputRef.current.focus();
          setNewCatIndex(null);
        }
      }, [localCategories.length, newCatIndex]);

      const handleDeleteCategory = (index) => {
        const cat = localCategories[index];
        if (getItemCount(cat.id) === 0) {
          setLocalCategories(prev => prev.filter((_, i) => i !== index));
          if (cat.id && !cat.id.startsWith('cat_')) {
            onDelete(cat.id);
          }
        }
      };

      const [dropIndex, setDropIndex] = useState(-1);
      const [justDroppedCatId, setJustDroppedCatId] = useState(null);

      const handleDragStart = (e, index) => {
        setDraggedIndex(index);
        e.dataTransfer.effectAllowed = 'move';
      };

      const handleDragOver = (e, index) => {
        e.preventDefault();
        if (draggedIndex === null) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const midY = rect.top + rect.height / 2;
        const target = e.clientY < midY ? index : index + 1;
        // Don't show indicator at no-op positions (right before or after dragged item)
        if (target === draggedIndex || target === draggedIndex + 1) {
          setDropIndex(-1);
        } else {
          setDropIndex(target);
        }
      };

      const handleDragEnd = () => {
        if (draggedIndex !== null && dropIndex >= 0) {
          const droppedId = localCategories[draggedIndex].id;
          setLocalCategories(prev => {
            const updated = [...prev];
            const [dragged] = updated.splice(draggedIndex, 1);
            const insertAt = dropIndex > draggedIndex ? dropIndex - 1 : dropIndex;
            updated.splice(insertAt, 0, dragged);
            return updated;
          });
          setJustDroppedCatId(droppedId);
          setTimeout(() => setJustDroppedCatId(null), 300);
        }
        setDraggedIndex(null);
        setDropIndex(-1);
      };

      const handleDragLeave = (e) => {
        // Only clear if leaving the list container, not moving between children
        if (!e.currentTarget.contains(e.relatedTarget)) {
          setDropIndex(-1);
        }
      };

      const handleSave = () => {
        // Save all categories and their new order
        localCategories.forEach((cat, index) => {
          if (cat.name.trim()) {
            onSave({ ...cat, name: cat.name.trim(), sortOrder: index });
          }
        });
        onReorder(localCategories.filter(c => c.name.trim()).map(c => c.id));
        onClose();
      };

      return (
        <div className="modal-overlay" onClick={onClose}>
          <div className="modal-body" onClick={e => e.stopPropagation()}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '4px' }}>
              <div>
                <h3 style={{ margin: 0, fontSize: '1rem', fontWeight: '600' }}>Editar categorías</h3>
                <div className="form-label" style={{ marginTop: '2px', marginBottom: 0 }}>
                  {items.length} items en total
                </div>
              </div>
              {/* Close via clicking outside or Escape */}
            </div>

            <div style={{ display: 'flex', flexDirection: 'column', gap: '0', marginBottom: '16px', marginTop: '12px' }} onDragLeave={handleDragLeave}>
              {localCategories.map((cat, index) => (
                <React.Fragment key={cat.id}>
                  <div className={`drop-indicator ${dropIndex === index ? 'visible' : ''}`} style={{ margin: '0' }} />
                  <div
                    draggable
                    onDragStart={(e) => handleDragStart(e, index)}
                    onDragOver={(e) => handleDragOver(e, index)}
                    onDragEnd={handleDragEnd}
                    className={`cat-modal-row ${justDroppedCatId === cat.id ? 'just-dropped' : ''}`}
                    style={{ opacity: draggedIndex === index ? 0.4 : 1, marginBottom: '8px' }}
                  >
                  {/* Drag handle */}
                  <div style={{ color: 'var(--text-muted)', cursor: 'grab' }}>⋮⋮</div>

                  {/* Color swatch that opens color popover */}
                  <div
                    onClick={(e) => { e.stopPropagation(); setColorPickerIndex(colorPickerIndex === index ? null : index); }}
                    className="cat-swatch-lg"
                    style={{ background: cat.color }}
                  />

                  {/* Color picker popover */}
                  {colorPickerIndex === index && (
                    <div className="color-picker-dropdown">
                      {COLORS.map(c => (
                        <button
                          key={c}
                          onClick={(e) => { e.stopPropagation(); handleColorChange(index, c); }}
                          style={{
                            width: '24px',
                            height: '24px',
                            borderRadius: '4px',
                            border: cat.color === c ? '2px solid var(--text-primary)' : 'none',
                            background: c,
                            cursor: 'pointer',
                            padding: 0,
                          }}
                        />
                      ))}
                    </div>
                  )}

                  {/* Name input */}
                  <input
                    ref={index === localCategories.length - 1 && newCatIndex === index ? newCatInputRef : null}
                    value={cat.name}
                    onChange={(e) => handleNameChange(index, e.target.value)}
                    placeholder="Nombre..."
                    className="form-control form-control-md"
                    style={{ flex: 1, padding: '6px 8px' }}
                  />

                  {/* Item count */}
                  <span className="form-label" style={{ minWidth: '20px', textAlign: 'right', marginBottom: 0 }}>
                    {getItemCount(cat.id)}
                  </span>
                </div>
                </React.Fragment>
              ))}
              <div className={`drop-indicator ${dropIndex === localCategories.length ? 'visible' : ''}`} style={{ margin: '0' }} />
            </div>

            <div className="popover-actions">
              <button onClick={handleAddCategory} className="btn btn-submit-lg">
                Agregar categoría
              </button>
              <button onClick={handleSave} className="btn btn-primary btn-submit-lg">
                Guardar
              </button>
            </div>
          </div>
        </div>
      );
    };

    const CalendarPopover = ({ baseDate, onSelectDate, onClose, targetRect, visibleDates, isMobile = false }) => {
      const [viewMonth, setViewMonth] = useState(baseDate.getMonth());
      const [viewYear, setViewYear] = useState(baseDate.getFullYear());
      const firstDay = new Date(viewYear, viewMonth, 1);
      const lastDay = new Date(viewYear, viewMonth + 1, 0);
      const days = [];
      for (let i = 0; i < firstDay.getDay(); i++) days.push(null);
      for (let i = 1; i <= lastDay.getDate(); i++) days.push(new Date(viewYear, viewMonth, i));

      // In mobile, don't show the 12 visible days highlight
      const isVisible = (d) => !isMobile && visibleDates.some(v => formatDate(v) === formatDate(d));
      const isToday = (d) => formatDate(d) === formatDate(REAL_TODAY);

      const minDate = new Date(REAL_TODAY);
      minDate.setMonth(minDate.getMonth() - 2);
      const maxDate = new Date(REAL_TODAY);
      maxDate.setMonth(maxDate.getMonth() + 2);

      const canGoBack = viewYear > minDate.getFullYear() || (viewYear === minDate.getFullYear() && viewMonth > minDate.getMonth());
      const canGoForward = viewYear < maxDate.getFullYear() || (viewYear === maxDate.getFullYear() && viewMonth < maxDate.getMonth());

      const cellSize = isMobile ? 44 : 28;
      const fontSize = isMobile ? '1rem' : '0.625rem';
      const headerFontSize = isMobile ? '1rem' : '0.75rem';
      const dayLabelFontSize = isMobile ? '0.75rem' : '0.5625rem';

      return (
        <Popover onClose={onClose} targetRect={targetRect}>
          <div style={{ width: isMobile ? '100%' : 'auto' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: isMobile ? '12px' : '8px' }}>
              <button onClick={() => canGoBack && (viewMonth === 0 ? (setViewMonth(11), setViewYear(y => y-1)) : setViewMonth(m => m-1))} className="btn" style={{ padding: isMobile ? '10px 14px' : undefined }} disabled={!canGoBack}>←</button>
              <span style={{ fontWeight: '600', fontSize: headerFontSize }}>{getMonthName(new Date(viewYear, viewMonth))} {viewYear}</span>
              <button onClick={() => canGoForward && (viewMonth === 11 ? (setViewMonth(0), setViewYear(y => y+1)) : setViewMonth(m => m+1))} className="btn" style={{ padding: isMobile ? '10px 14px' : undefined }} disabled={!canGoForward}>→</button>
            </div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: isMobile ? '4px' : '2px', fontSize: dayLabelFontSize, textAlign: 'center', color: 'var(--text-muted)', marginBottom: isMobile ? '8px' : '4px' }}>
              {DAYS.map((d,i) => <div key={i}>{d.charAt(0)}</div>)}
            </div>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(7, 1fr)', gap: isMobile ? '4px' : '2px' }}>
              {days.map((d, i) => {
                const today = d && isToday(d);
                const visible = d && isVisible(d);
                return (
                  <button key={i} onClick={() => d && onSelectDate(d)} disabled={!d} style={{
                    width: cellSize, height: cellSize, display: 'flex', alignItems: 'center', justifyContent: 'center',
                    borderRadius: '4px', fontSize, border: 'none', cursor: d ? 'pointer' : 'default',
                    background: today ? 'var(--accent-blue)' : visible ? 'rgba(59, 125, 216, 0.15)' : 'transparent',
                    color: d ? (today ? '#FFFFFF' : visible ? 'var(--accent-blue)' : 'var(--text-primary)') : 'transparent',
                    fontWeight: today ? '700' : visible ? '500' : '400',
                  }}>{d?.getDate()}</button>
                );
              })}
            </div>
          </div>
        </Popover>
      );
    };

    const RecurringActionPopover = ({ item, originalDate, visualDate, targetDate, targetSlot, action, onConfirm, onCancel, targetRect, pendingItemId }) => {
      const originalRepeatType = item.repeat?.type || 'days';
      const originalEvery = item.repeat?.every || 1;
      const originalDays = item.repeat?.days || [];

      console.log('RecurringActionPopover item:', item);
      console.log('originalRepeatType:', originalRepeatType, 'originalEvery:', originalEvery);

      // Check if target date's day of week is outside the weekdays pattern
      const targetDayOfWeek = new Date(targetDate + 'T00:00:00').getDay();
      const isTargetOutsidePattern = originalRepeatType === 'weekdays' && !originalDays.includes(targetDayOfWeek);

      const [showFollowingOptions, setShowFollowingOptions] = useState(false);
      const [newRepeatType, setNewRepeatType] = useState(originalRepeatType);
      // If target is outside pattern, pre-add that day to selectedDays
      const [selectedDays, setSelectedDays] = useState(() => {
        if (isTargetOutsidePattern) {
          return [...originalDays, targetDayOfWeek].sort((a, b) => a - b);
        }
        return originalDays;
      });
      const [newEvery, setNewEvery] = useState(originalEvery);
      const [computedRect, setComputedRect] = useState(targetRect);

      // Find the pending item element and position popover below it
      useEffect(() => {
        if (pendingItemId) {
          // Small delay to let the DOM update
          const timer = setTimeout(() => {
            const pendingElement = document.querySelector(`[data-item-id="${pendingItemId}"]`);
            if (pendingElement) {
              const rect = pendingElement.getBoundingClientRect();
              setComputedRect(rect);
            }
          }, 50);
          return () => clearTimeout(timer);
        }
      }, [pendingItemId]);

      const dayNames = ['D', 'L', 'M', 'M', 'J', 'V', 'S'];

      // Check if config is valid (required to confirm)
      const hasValidConfig = newRepeatType === 'weekdays'
        ? selectedDays.length > 0
        : newEvery >= 1;

      // Check if anything changed from original
      const typeChanged = newRepeatType !== originalRepeatType;
      const everyChanged = newEvery !== originalEvery;
      const daysChanged = newRepeatType === 'weekdays' && (
        selectedDays.length !== originalDays.length ||
        !selectedDays.every(d => originalDays.includes(d))
      );
      // Moving to a different date is also a change (enables the button)
      const dateChanged = visualDate !== targetDate;
      const hasChanges = typeChanged || everyChanged || daysChanged || dateChanged;

      const getSlotName = (slot) => {
        if (slot === 'important') return 'Importante';
        if (slot === 'todo') return 'Pendiente';
        if (slot === 'done') return 'Hecho';
        return slot;
      };

      const title = action === 'move'
        ? `Mover a ${formatDateLabel(targetDate)}`
        : `Cambiar a ${getSlotName(targetSlot)}`;

      // If moving to "done", only "solo este evento" makes sense
      const isDoneTarget = targetSlot === 'done';

      const toggleDay = (dayIndex) => {
        setSelectedDays(prev =>
          prev.includes(dayIndex)
            ? prev.filter(d => d !== dayIndex)
            : [...prev, dayIndex].sort((a, b) => a - b)
        );
      };

      const handleFollowingClick = () => {
        setShowFollowingOptions(true);
      };

      const handleFollowingConfirm = () => {
        const options = { newRepeatType };
        if (newRepeatType === 'weekdays') {
          options.newDays = selectedDays;
        } else {
          options.newEvery = newEvery;
        }
        console.log('handleFollowingConfirm options:', options);
        onConfirm('following', options);
      };

      // Detectar si es weekdays para mostrar opciones diferentes
      const isWeekdays = originalRepeatType === 'weekdays';

      return (
        <Popover onClose={onCancel} targetRect={computedRect}>
          <div className="popover-info">
            <div className="popover-title">{title}</div>
            <div className="popover-subtitle" style={{ marginBottom: '12px' }}>"{item.title}"</div>
          </div>
          <div className="popover-actions-col">
            <button onClick={() => onConfirm('this')} className="btn btn-action">
              <div>Solo este evento</div>
              <div className="btn-action-hint">
                Mover solo esta instancia
              </div>
            </button>
            {/* Para weekdays: mostrar "Modificar repetición" que expande opciones */}
            {!isDoneTarget && isWeekdays && !showFollowingOptions && (
              <button onClick={handleFollowingClick} className="btn btn-action">
                <div>Modificar repetición</div>
                <div className="btn-action-hint">
                  Cambiar días a partir de esta fecha
                </div>
              </button>
            )}
            {/* Para days/weeks: mostrar "Este y los siguientes" */}
            {!isDoneTarget && !isWeekdays && !showFollowingOptions && (
              <button onClick={handleFollowingClick} className="btn btn-action">
                Este y los siguientes
              </button>
            )}
            {/* Para days/weeks: mostrar "Todos los eventos" */}
            {!isDoneTarget && !isWeekdays && !showFollowingOptions && (
              <button onClick={() => onConfirm('all')} className="btn btn-action">
                Todos los eventos
              </button>
            )}
            {showFollowingOptions && (
              <div style={{
                padding: '12px',
                background: 'var(--bg-secondary)',
                borderRadius: '6px',
                marginTop: '4px'
              }}>
                <div style={{ fontSize: '0.6875rem', color: 'var(--text-muted)', marginBottom: '10px' }}>

                  {isWeekdays
                    ? `Seleccioná los días a partir de ${formatDateLabel(targetDate)}:`
                    : `La serie continuará a partir de ${formatDateLabel(targetDate)}:`
                  }
                </div>

                {/* Repeat type selector - solo para days/weeks, no para weekdays */}
                {!isWeekdays && (
                  <select
                    value={newRepeatType}
                    onChange={(e) => setNewRepeatType(e.target.value)}
                    className="form-control form-group"
                    style={{ padding: '6px', fontSize: '0.625rem' }}
                  >
                    <option value="days">Cada X días</option>
                    <option value="weeks">Cada X semanas</option>
                    <option value="weekdays">Días de semana</option>
                  </select>
                )}

                {/* Days/Weeks frequency input */}
                {(newRepeatType === 'days' || newRepeatType === 'weeks') && (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '12px' }}>
                    <span style={{ fontSize: '0.6875rem', color: 'var(--text-primary)' }}>Cada</span>
                    <input
                      type="number"
                      min="1"
                      max="30"
                      value={newEvery}
                      onChange={(e) => setNewEvery(Math.max(1, parseInt(e.target.value) || 1))}
                      className="form-control form-control-sm"
                      style={{ width: '50px', textAlign: 'center' }}
                    />
                    <span style={{ fontSize: '0.6875rem', color: 'var(--text-primary)' }}>
                      {newRepeatType === 'days' ? (newEvery === 1 ? 'día' : 'días') : (newEvery === 1 ? 'semana' : 'semanas')}
                    </span>
                  </div>
                )}

                {/* Weekdays selector */}
                {newRepeatType === 'weekdays' && (
                  <>
                    {isTargetOutsidePattern && (
                      <div style={{
                        fontSize: '0.5625rem',
                        color: 'var(--accent-yellow)',
                        marginBottom: '8px',
                        padding: '6px 8px',
                        background: 'rgba(245, 158, 11, 0.15)',
                        borderRadius: '4px',
                      }}>
                        {DAYS_FULL[targetDayOfWeek]} no está en tu patrón. Se agregará.
                      </div>
                    )}
                    <div style={{ display: 'flex', gap: '4px', marginBottom: '12px' }}>
                    {dayNames.map((name, idx) => (
                      <button
                        key={idx}
                        onClick={() => toggleDay(idx)}
                        style={{
                          width: '28px',
                          height: '28px',
                          borderRadius: '50%',
                          border: 'none',
                          background: selectedDays.includes(idx) ? 'var(--accent-blue)' : 'var(--bg-tertiary)',
                          color: selectedDays.includes(idx) ? 'white' : 'var(--text-primary)',
                          fontSize: '0.625rem',
                          fontWeight: '500',
                          cursor: 'pointer',
                        }}
                      >
                        {name}
                      </button>
                    ))}
                    </div>
                  </>
                )}

                <button
                  onClick={handleFollowingConfirm}
                  className="btn btn-primary"
                  disabled={!hasValidConfig || !hasChanges}
                  style={{
                    width: '100%',
                    padding: '8px',
                    fontSize: '0.6875rem',
                    opacity: (!hasValidConfig || !hasChanges) ? 0.5 : 1,
                  }}
                >
                  {isWeekdays ? 'Aplicar cambios' : 'Aplicar a este y los siguientes'}
                </button>
              </div>
            )}
          </div>
        </Popover>
      );
    };

    const RecurringDeletePopover = ({ item, onConfirm, onCancel, targetRect }) => {
      const isWeekdays = item.repeat?.type === 'weekdays';

      return (
        <Popover onClose={onCancel} targetRect={targetRect}>
          <div className="popover-info">
            <div className="popover-title">Borrar evento recurrente</div>
            <div className="popover-subtitle" style={{ marginBottom: '12px' }}>"{item.title}"</div>
          </div>
          <div className="popover-actions-col">
            <button onClick={() => onConfirm('this')} className="btn btn-action">
              <div>Solo este evento</div>
              <div className="btn-action-hint">
                Eliminar solo esta instancia
              </div>
            </button>
            {!isWeekdays && (
              <button onClick={() => onConfirm('following')} className="btn btn-action">
                <div>Este y los siguientes</div>
                <div className="btn-action-hint">
                  Eliminar desde esta fecha en adelante
                </div>
              </button>
            )}
            <button onClick={() => onConfirm('all')} className="btn btn-action">
              <div>Todos los eventos</div>
              <div className="btn-action-hint">
                Eliminar toda la serie
              </div>
            </button>
          </div>
        </Popover>
      );
    };

    const RemoveDatePopover = ({ itemTitle, onConfirm, onCancel, targetRect, isRecurring }) => {
      return (
        <Popover onClose={onCancel} targetRect={targetRect}>
          <div className="popover-info">
            {isRecurring
              ? `Para hacer esto hay que eliminar la recurrencia de "${itemTitle}"`
              : `Para hacer esto hay que eliminar la fecha de "${itemTitle}"`
            }
          </div>
          <div className="popover-actions">
            <button onClick={onConfirm} className="btn btn-primary btn-submit">
              {isRecurring ? 'Eliminar recurrencia' : 'Eliminar fecha'}
            </button>
          </div>
        </Popover>
      );
    };

    const RemoveRecurrenceAlertPopover = ({ itemTitle, onConfirm, onCancel, targetRect }) => {
      return (
        <Popover onClose={onCancel} targetRect={targetRect}>
          <div className="popover-info">
            <div className="popover-title">¿Quitar recurrencia?</div>
            <div className="popover-subtitle">
              Al mover "{itemTitle}" a esta posición, solo se modificará este evento sin afectar los siguientes.
            </div>
          </div>
          <div className="popover-actions">
            <button onClick={onCancel} className="btn btn-submit">
              Cancelar
            </button>
            <button onClick={onConfirm} className="btn btn-primary btn-submit">
              Confirmar
            </button>
          </div>
        </Popover>
      );
    };

    const RecurringSavePopover = ({ itemTitle, onThis, onFollowing, onCancel, targetRect }) => {
      return (
        <Popover onClose={onCancel} targetRect={targetRect}>
          <div className="popover-info">
            <div className="popover-title">Guardar cambios</div>
            <div className="popover-subtitle" style={{ marginBottom: '12px' }}>"{itemTitle}"</div>
          </div>
          <div className="popover-actions-col">
            <button onClick={onThis} className="btn btn-action">
              Solo este evento
            </button>
            <button onClick={onFollowing} className="btn btn-action">
              Este y los siguientes
            </button>
          </div>
        </Popover>
      );
    };

    const ItemCard = ({ item, categories, onComplete, onEdit, onDelete, onToggleImportant, inSidebar, isToday, isPast, showDate, justDroppedItemId, justShimmeredItemId, draggingItemType, onDragTypeChange }) => {
      const [dragging, setDragging] = useState(false);
      const [canDrag, setCanDrag] = useState(true); // For mobile long-press
      const [justGrabbed, setJustGrabbed] = useState(false); // For grab animation
      const mouseDownPos = useRef(null);
      const touchStartPos = useRef(null);
      const longPressTimer = useRef(null);
      const cardRef = useRef(null);
      const cat = categories.find(c => c.id === item.category);

      // Detect mobile
      const isMobileDevice = typeof window !== 'undefined' && window.innerWidth <= 600;
      // For completion, use full ID (keeps date for recurring items)
      const completeId = item.id;
      // For drag/edit, use base ID
      const baseId = typeof item.id === 'string' && item.id.includes('-') ? item.originalId || item.id : item.id;

      // Handle click to edit - only if not dragging (no significant mouse movement)
      const handleMouseDown = (e) => {
        // Don't track if clicking on checkbox or important button
        if (e.target.closest('[data-checkbox]') || e.target.closest('[data-important-btn]')) return;
        mouseDownPos.current = { x: e.clientX, y: e.clientY };
      };

      const handleMouseUp = (e) => {
        // Don't handle if clicking on checkbox or important button
        if (e.target.closest('[data-checkbox]') || e.target.closest('[data-important-btn]')) return;
        if (!mouseDownPos.current) return;

        const dx = Math.abs(e.clientX - mouseDownPos.current.x);
        const dy = Math.abs(e.clientY - mouseDownPos.current.y);

        // If mouse moved less than 5px, treat as click (not drag)
        if (dx < 5 && dy < 5 && !dragging) {
          e.stopPropagation();
          // Don't open if a popover was just closed
          if (Date.now() - lastPopoverCloseTime < 200) {
            mouseDownPos.current = null;
            return;
          }
          if (cardRef.current) {
            onEdit(item, cardRef.current.getBoundingClientRect());
          }
        }
        mouseDownPos.current = null;
      };

      // Touch handlers for mobile - long press to enable drag
      // Only require delay for horizontal movement (swipe protection), not for vertical scroll
      const handleTouchStart = (e) => {
        if (e.target.closest('[data-checkbox]')) return;
        const touch = e.touches[0];
        touchStartPos.current = { x: touch.clientX, y: touch.clientY, time: Date.now() };

        // On mobile, disable drag initially - require long press
        if (isMobileDevice) {
          setCanDrag(false);
          // Only show grab shimmer after a meaningful long press (300ms)
          longPressTimer.current = setTimeout(() => {
            setCanDrag(true);
            setJustGrabbed(true);
            // Clear grab animation after it plays (600ms animation)
            setTimeout(() => setJustGrabbed(false), 600);
          }, 300);
        }
      };

      const handleTouchMove = (e) => {
        if (!touchStartPos.current) return;
        const touch = e.touches[0];
        const dx = Math.abs(touch.clientX - touchStartPos.current.x);
        const dy = Math.abs(touch.clientY - touchStartPos.current.y);

        // If moved more than 25px in any direction, cancel long press timer
        if (dx > 25 || dy > 25) {
          if (longPressTimer.current) {
            clearTimeout(longPressTimer.current);
            longPressTimer.current = null;
          }
          // Reset touch tracking so we don't interfere with scroll
          touchStartPos.current = null;
        }
      };

      const handleTouchEnd = (e) => {
        if (longPressTimer.current) {
          clearTimeout(longPressTimer.current);
          longPressTimer.current = null;
        }

        // Reset grab animation if touch ended quickly
        setJustGrabbed(false);

        if (!touchStartPos.current) return;

        const timeDelta = Date.now() - touchStartPos.current.time;
        const touch = e.changedTouches[0];
        const dx = Math.abs(touch.clientX - touchStartPos.current.x);
        const dy = Math.abs(touch.clientY - touchStartPos.current.y);

        // If short tap (< 200ms) and didn't move much, treat as click
        if (timeDelta < 200 && dx < 10 && dy < 10 && !dragging) {
          e.preventDefault();
          if (Date.now() - lastPopoverCloseTime < 200) {
            touchStartPos.current = null;
            setCanDrag(true);
            return;
          }
          if (cardRef.current) {
            onEdit(item, cardRef.current.getBoundingClientRect());
          }
        }

        touchStartPos.current = null;
        setCanDrag(true);
      };

      // For recurring items, we need both:
      // - exceptionDate: the date key in exceptions (for "solo este evento")
      // - visualDate: where the item appears visually (for "este y siguientes" / "todos")
      const getExceptionDate = () => {
        if (!item.repeat) return item.scheduledDate;
        // If it's a moved instance, use originalScheduledDate (the exception key)
        if (item.originalScheduledDate) return item.originalScheduledDate;
        // If id contains date, extract it (format: baseId-YYYY-MM-DD or baseId-YYYY-MM-DD-moved)
        if (typeof item.id === 'string' && item.id.includes('-')) {
          const parts = item.id.split('-');
          if (parts.length >= 4) {
            return `${parts[1]}-${parts[2]}-${parts[3]}`;
          }
        }
        return item.scheduledDate;
      };

      // originalSlot should reflect the visual slot - if completed, it's 'done'
      const visualSlot = item.completed ? 'done' : item.scheduledSlot;
      // visualDate for completed items should be the completedDate
      const visualDate = item.completed ? item.completedDate : item.scheduledDate;

      const dragData = JSON.stringify({
        id: baseId,
        isRecurring: !!item.repeat,
        exceptionDate: getExceptionDate(),
        visualDate: visualDate,
        originalSlot: visualSlot,
        title: item.title
      });

      // Determine card background based on context
      const getCardBackground = () => {
        if (inSidebar) return 'var(--bg-card)';
        if (isToday) return 'var(--bg-card-today)';
        if (isPast) return 'var(--bg-card-past)';
        return 'var(--bg-card-future)';
      };

      // Text color: important=yellow, completed=muted, overdue=red, recurring=blue, past=past, else normal
      const getTextColor = () => {
        if (item.completed) return 'var(--text-muted)';
        if (item.isImportant) return 'var(--accent-yellow)';
        if (item._isOverdue) return 'var(--accent-red)'; // Red for overdue recurring items
        if (item.repeat) return 'var(--accent-blue)';
        if (isPast) return 'var(--text-past)';
        return 'var(--text-primary)';
      };

      // Recurring item logic (for sidebar label)
      const isRecurring = !!item.repeat;
      const isScheduled = !!item.scheduledDate;

      // Check if this item was just dropped (for feedback animation)
      const itemBaseId = typeof item.id === 'string' ? parseInt(item.id.split('-')[0]) : item.id;
      const isJustDropped = justDroppedItemId && itemBaseId === justDroppedItemId;
      const isJustShimmered = justShimmeredItemId && itemBaseId === justShimmeredItemId;

      const [isHovered, setIsHovered] = useState(false);

      // Handle complete via checkbox
      const handleCheckboxClick = (e) => {
        e.stopPropagation();
        onComplete(completeId);
      };

      return (
        <div
          ref={cardRef}
          data-item-id={item.id}
          draggable={!isMobileDevice || canDrag}
          onDragStart={(e) => {
            if (isMobileDevice && !canDrag) { e.preventDefault(); return; }
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('itemData', dragData);
            // Hide the default drag ghost image
            const emptyImg = new Image();
            emptyImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            e.dataTransfer.setDragImage(emptyImg, 0, 0);
            setDragging(true);
            mouseDownPos.current = null;
            // Set dragging item type for zone muting
            const itemType = item.repeat ? 'recurring' : (item.isImportant ? 'important' : 'normal');
            onDragTypeChange?.(itemType);
          }}
          onDragEnd={() => { setDragging(false); onDragTypeChange?.(null); }}
          className={`draggable ${dragging ? 'dragging' : ''} ${item._isPending ? 'pending-drop' : ''} ${isJustDropped ? 'just-dropped' : ''} ${justGrabbed ? 'just-grabbed' : ''} ${isJustShimmered ? 'just-shimmered' : ''}`}
          onMouseDown={handleMouseDown}
          onMouseUp={handleMouseUp}
          onTouchStart={handleTouchStart}
          onTouchMove={handleTouchMove}
          onTouchEnd={handleTouchEnd}
          onMouseEnter={() => setIsHovered(true)}
          onMouseLeave={() => setIsHovered(false)}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: isMobileDevice ? '8px' : '6px',
            padding: isMobileDevice ? '6px 0' : '2px 0',
            background: 'transparent',
            borderRadius: '3px',
            // Mute logic: when dragging recurring, mute normal zone; when dragging important/normal, mute recurring zone
            opacity: (() => {
              if (item.completed) return 0.5;
              if (item._isPending) return 0.7;
              if (draggingItemType === 'recurring' && !item.repeat) return 0.3; // Mute normal zone
              if ((draggingItemType === 'important' || draggingItemType === 'normal') && item.repeat) return 0.3; // Mute recurring zone
              return 1;
            })(),
            touchAction: 'manipulation',
          }}
        >
          {/* Title */}
          <div style={{ flex: 1, minWidth: 0 }}>
            <div style={{
              fontSize: isMobileDevice ? '0.875rem' : '0.625rem',
              fontWeight: '400',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
              color: getTextColor(),
              textDecoration: item.completed ? 'line-through' : 'none',
              lineHeight: isMobileDevice ? '1.3' : '1.2',
            }}>
              {item.title}
            </div>
          </div>
          {/* Status icons container */}
          <div style={{
            display: 'flex',
            gap: '0',
            alignItems: 'center',
          }}>
            {/* DESKTOP: Icons always visible, checkbox on hover */}
            {!isMobileDevice && (
              <>
                {/* Recurrence icon - always visible, red if overdue */}
                {item.repeat && (
                  <div
                    title={getRecurrenceTooltip(item.repeat)}
                    className="icon-box icon-box-sm"
                  >
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke={item._isOverdue ? 'var(--accent-red)' : 'var(--accent-blue)'} strokeWidth="2">
                      <path d="M17 1l4 4-4 4"/>
                      <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                      <path d="M7 23l-4-4 4-4"/>
                      <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                    </svg>
                  </div>
                )}
                {/* Important icon - always visible for non-recurring items */}
                {!item.repeat && (
                  <div
                    data-important-btn="true"
                    onClick={(e) => { e.stopPropagation(); onToggleImportant?.(item.id); }}
                    className="icon-box icon-box-sm"
                    style={{
                      cursor: 'pointer',
                      color: item.isImportant ? 'var(--accent-yellow)' : 'var(--text-muted)',
                      opacity: isHovered || item.isImportant ? 1 : 0,
                      transition: 'opacity 0.1s',
                    }}
                    title={item.isImportant ? "Quitar importante" : "Marcar importante"}
                  >
                    <svg width="14" height="14" viewBox="0 0 24 24" fill={item.isImportant ? 'var(--accent-yellow)' : 'none'} stroke={item.isImportant ? 'var(--accent-yellow)' : 'currentColor'} strokeWidth="2">
                      <circle cx="12" cy="12" r="10"/>
                      <line x1="12" y1="7" x2="12" y2="13" stroke={item.isImportant ? 'white' : 'currentColor'}/>
                      <circle cx="12" cy="17" r="1" fill={item.isImportant ? 'white' : 'currentColor'}/>
                    </svg>
                  </div>
                )}
                {/* Checkbox - appears on hover, shifts icons left */}
                <div
                  data-checkbox="true"
                  onClick={handleCheckboxClick}
                  className="icon-box"
                  style={{
                    width: isHovered || item.completed ? '20px' : '0px',
                    height: '20px',
                    cursor: 'pointer',
                    overflow: 'hidden',
                    transition: 'width 0.1s',
                  }}
                >
                  <div className="checkbox-inner" style={{
                    width: '14px', height: '14px',
                    border: `1px solid ${item.completed ? 'var(--accent-green)' : 'var(--text-muted)'}`,
                    background: item.completed ? 'var(--accent-green)' : 'transparent',
                  }}>
                    {item.completed && (
                      <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                    )}
                  </div>
                </div>
              </>
            )}
            {/* MOBILE: Only show icons if state is active */}
            {isMobileDevice && (
              <>
                {/* Recurrence icon - always visible, red if overdue */}
                {item.repeat && (
                  <div title={getRecurrenceTooltip(item.repeat)} className="icon-box icon-box-md">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke={item._isOverdue ? 'var(--accent-red)' : 'var(--accent-blue)'} strokeWidth="2">
                      <path d="M17 1l4 4-4 4"/>
                      <path d="M3 11V9a4 4 0 0 1 4-4h14"/>
                      <path d="M7 23l-4-4 4-4"/>
                      <path d="M21 13v2a4 4 0 0 1-4 4H3"/>
                    </svg>
                  </div>
                )}
                {/* Important icon - only if important */}
                {item.isImportant && !item.repeat && (
                  <div className="icon-box icon-box-md">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="var(--accent-yellow)" stroke="var(--accent-yellow)" strokeWidth="2">
                      <circle cx="12" cy="12" r="10"/>
                      <line x1="12" y1="7" x2="12" y2="13" stroke="white"/>
                      <circle cx="12" cy="17" r="1" fill="white"/>
                    </svg>
                  </div>
                )}
                {/* Checkbox - only if completed */}
                {item.completed && (
                  <div className="icon-box icon-box-md">
                    <div className="checkbox-inner" style={{
                      width: '16px', height: '16px',
                      border: '1px solid var(--accent-green)', background: 'var(--accent-green)',
                    }}>
                      <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                      </svg>
                    </div>
                  </div>
                )}
              </>
            )}
          </div>
        </div>
      );
    };

    const SlotSection = ({ slot, label, items, energy, categories, onComplete, onEdit, onDelete, onDrop, onAdd, dateStr, isDone, isToday, isPast, justDroppedItemId, allowClickToAdd }) => {
      const [newItemId, setNewItemId] = useState(null);
      const [editRect, setEditRect] = useState(null);
      const [dropIndex, setDropIndex] = useState(-1);
      const newItemRef = useRef(null);
      const slotEffort = items.filter(i => !i.completed).reduce((s, i) => s + i.effort, 0);
      const itemCount = items.length;

      // Create item and show edit popover
      // addAtEnd: true = add at bottom (click on empty area), false = add at top (+ button)
      const handleAddItem = (e, addAtEnd = false) => {
        e.stopPropagation();
        // Don't create if a popover was just closed
        if (Date.now() - lastPopoverCloseTime < 200) return;
        // Calculate sortOrder: negative for top, positive for bottom
        const minSortOrder = items.length > 0 ? Math.min(...items.map(i => i.sortOrder || 0)) : 0;
        const maxSortOrder = items.length > 0 ? Math.max(...items.map(i => i.sortOrder || 0)) : 0;
        const sortOrder = addAtEnd ? maxSortOrder + 1 : minSortOrder - 1;
        onAdd({
          title: '',
          description: '',
          category: 'temp',
          effort: 1,
          repeat: null,
          scheduledDate: dateStr,
          scheduledSlot: slot,
          completed: isDone,
          completedDate: isDone ? dateStr : null,
          sortOrder,
          _isNewItem: true, // Marker to identify this item
          _addAtEnd: addAtEnd, // For finding the item in DOM
        });
        setNewItemId('pending'); // Flag that we're waiting for a new item
      };

      // Handle closing the popover - deletion is now handled by AddEditItemPopover
      const handleClosePopover = () => {
        setEditRect(null);
      };

      // Show edit popover once new item is rendered
      useEffect(() => {
        if (newItemId === 'pending') {
          // Find the newest item with _isNewItem marker in this slot
          const newestItem = items.find(i => i._isNewItem);
          if (newestItem) {
            // Use setTimeout to ensure DOM is fully rendered
            const timer = setTimeout(() => {
              if (newItemRef.current) {
                const rect = newItemRef.current.getBoundingClientRect();
                setEditRect({ itemId: newestItem.id, rect });
                setNewItemId(null);
              } else {
                // Retry with another timeout if ref not ready
                setTimeout(() => {
                  if (newItemRef.current) {
                    const rect = newItemRef.current.getBoundingClientRect();
                    setEditRect({ itemId: newestItem.id, rect });
                  }
                  setNewItemId(null);
                }, 50);
              }
            }, 10);
            return () => clearTimeout(timer);
          }
        }
      }, [newItemId, items]);

      const hasItemData = (e) => Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata');

      const handleItemDragOver = (e, index) => {
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          // Detect if cursor is in top or bottom half of item
          const rect = e.currentTarget.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const isTopHalf = y < rect.height / 2;
          setDropIndex(isTopHalf ? index : index + 1);
        }
      };

      const handleSlotDragOver = (e) => {
        if (hasItemData(e)) {
          e.preventDefault();
          // Only set drop index if not over any item
          if (!e.target.closest('[data-item]')) {
            // If empty slot or cursor is below all items, append at end
            const slotArea = e.currentTarget.querySelector('.slot-empty-area');
            if (slotArea) {
              const itemElements = slotArea.querySelectorAll('[data-item]');
              if (itemElements.length === 0) {
                setDropIndex(0);
              } else {
                // Check if cursor is below all items
                const lastItem = itemElements[itemElements.length - 1];
                const lastRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastRect.bottom) {
                  setDropIndex(items.length);
                } else if (e.clientY < itemElements[0].getBoundingClientRect().top) {
                  setDropIndex(0);
                }
              }
            } else {
              setDropIndex(0);
            }
          }
        }
      };

      const handleDragLeave = (e) => {
        // Only clear if leaving the slot entirely
        if (!e.currentTarget.contains(e.relatedTarget)) {
          setDropIndex(-1);
        }
      };

      const handleDrop = (e) => {
        e.preventDefault();
        const currentDropIndex = dropIndex;
        setDropIndex(-1);
        const data = e.dataTransfer.getData('itemData');
        if (data) onDrop(JSON.parse(data), slot, currentDropIndex, { x: e.clientX, y: e.clientY });
      };

      // Find the item we just created (by newItemId) to attach ref
      const editingItem = editRect ? items.find(i => i.id === editRect.itemId) : null;

      return (
        <>
          <div
            className={isDone ? 'slot-row-done' : 'slot-row'}
            style={{ cursor: 'pointer' }}
            onDragOver={handleSlotDragOver}
            onDragLeave={handleDragLeave}
            onDrop={handleDrop}
          >
            <div onClick={(e) => handleAddItem(e, true)} style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
              <div className="slot-header" onClick={(e) => e.stopPropagation()}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px' }}>
                  <span className="slot-label" style={{ color: isDone ? 'var(--accent-green)' : slot === 'important' ? '#EF4444' : 'var(--text-secondary)' }}>{label} ({itemCount})</span>
                </div>
                {!isDone && <button onClick={(e) => handleAddItem(e, false)} className="btn" style={{ fontWeight: '700', padding: '1px 5px' }}><span className="btn-top-adjust">+</span></button>}
              </div>
              <div className="slot-empty-area slot-items">
                {/* Drop indicator at top */}
                <div className={`drop-indicator ${dropIndex === 0 ? 'visible' : ''}`} />
                {items.map((item, index) => (
                  <div
                    key={item.id}
                    ref={item._isNewItem ? newItemRef : null}
                    data-item="true"
                    onDragOver={(e) => handleItemDragOver(e, index)}
                  >
                    <div
                      style={{ marginBottom: '6px' }}
                      onClick={(e) => e.stopPropagation()}
                    >
                      <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={onEdit} isToday={isToday} isPast={isPast} justDroppedItemId={justDroppedItemId} />
                    </div>
                    {/* Drop indicator after each item (except last - that's handled by bottom area) */}
                    {index < items.length - 1 && <div className={`drop-indicator ${dropIndex === index + 1 ? 'visible' : ''}`} />}
                  </div>
                ))}
                {/* Dashed add button - right after last item (not for Done slot) */}
                <div className={`drop-indicator ${dropIndex === items.length && items.length > 0 ? 'visible' : ''}`} />
                {!isDone && (
                  <button onClick={(e) => handleAddItem(e, true)} className="btn-add-dashed">
                    Agregar
                  </button>
                )}
                {/* Bottom padding for Done slot */}
                {isDone && <div style={{ height: '6px', flexShrink: 0 }} />}
                {/* Bottom drop area - allows clicking empty area to add */}
                {allowClickToAdd && (
                  <div
                    style={{ flex: 1, minHeight: '10px' }}
                    onDragOver={(e) => {
                      if (hasItemData(e)) {
                        e.preventDefault();
                        e.stopPropagation();
                        setDropIndex(items.length);
                      }
                    }}
                  />
                )}
              </div>
            </div>
          </div>
          {editRect && editingItem && ReactDOM.createPortal(
            <AddEditItemPopover
              categories={categories}
              onSave={onAdd}
              onDelete={onDelete}
              onComplete={onComplete}
              onClose={handleClosePopover}
              targetRect={editRect.rect}
              editItem={editingItem}
            />,
            document.body
          )}
        </>
      );
    };

    const DayColumn = ({ day, items, categories, dayEnergy, onComplete, onEdit, onDelete, onToggleImportant, onDrop, onAdd, onSetEnergy, isSticky, justDroppedItemId, draggingItemType, onDragTypeChange, draggingRecurringRange }) => {
      const dateStr = formatDate(day.date);
      const isToday = formatDate(day.date) === formatDate(REAL_TODAY);
      const isSunday = day.date.getDay() === 0;

      // Get all items for this day (both pending and completed)
      // NEW ZONE LOGIC:
      // - Zone 1 (Recurring): recurring items + completed recurring items (sorted by sortOrder)
      // - Zone 2 (Normal): normal + important + completed normal/important (sorted by sortOrder)
      // Completed items stay in their original position (don't move to end)
      const dayItems = items.filter(i =>
        (i.scheduledDate === dateStr && !i.completed) ||
        (i.completedDate === dateStr && i.completed)
      ).sort((a, b) => {
        // Zone separation: recurring items first, then normal items
        if (!!a.repeat !== !!b.repeat) return a.repeat ? -1 : 1;
        // Within same zone, sort by sortOrder (completed items stay in place)
        return (a.sortOrder || 0) - (b.sortOrder || 0);
      });

      // Separate items into zones for visual rendering
      const recurringZone = dayItems.filter(i => i.repeat);
      const normalZone = dayItems.filter(i => !i.repeat);

      // Check if drop is valid at a given index based on dragging item type
      const isDropValidAtIndex = (index) => {
        if (!draggingItemType) return true; // No item being dragged
        const recurringZoneEnd = recurringZone.length;
        if (draggingItemType === 'recurring') {
          // Recurring items can only go in recurring zone (indices 0 to recurringZoneEnd)
          return index <= recurringZoneEnd;
        } else {
          // Normal/important items can only go in normal zone (indices >= recurringZoneEnd)
          return index >= recurringZoneEnd;
        }
      };

      const [dropIndex, setDropIndex] = useState(-1);
      const [newItemId, setNewItemId] = useState(null);
      const [editRect, setEditRect] = useState(null);
      const newItemRef = useRef(null);
      const columnRef = useRef(null);

      // Sunday line color - desaturated blue/gray
      const sundayLineColor = 'rgba(100, 116, 139, 0.5)';

      const hasItemData = (e) => Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata');

      const handleItemDragOver = (e, index) => {
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          const rect = e.currentTarget.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const isTopHalf = y < rect.height / 2;
          let targetIndex = isTopHalf ? index : index + 1;

          // If dragging a recurring item over normal zone, clamp to end of recurring zone
          if (draggingItemType === 'recurring' && targetIndex > recurringZone.length) {
            targetIndex = recurringZone.length;
          }
          // If dragging a normal item over recurring zone, clamp to start of normal zone
          if ((draggingItemType === 'normal' || draggingItemType === 'important') && targetIndex < recurringZone.length) {
            targetIndex = recurringZone.length;
          }

          setDropIndex(targetIndex);
        }
      };

      const handleColumnDragOver = (e) => {
        if (hasItemData(e)) {
          e.preventDefault();
          if (!e.target.closest('[data-day-item]')) {
            // If dragging a recurring item, drop at end of recurring zone, not end of all items
            if (draggingItemType === 'recurring') {
              setDropIndex(recurringZone.length);
            } else {
              setDropIndex(dayItems.length);
            }
          }
        }
      };

      const handleDragLeave = (e) => {
        if (columnRef.current && !columnRef.current.contains(e.relatedTarget)) {
          setDropIndex(-1);
        }
      };

      const handleDrop = (e) => {
        e.preventDefault();
        const currentDropIndex = dropIndex;
        setDropIndex(-1);
        onDragTypeChange?.(null); // Reset mute state on drop
        const data = e.dataTransfer.getData('itemData');
        if (data) {
          onDrop(JSON.parse(data), dateStr, 'todo', currentDropIndex, { x: e.clientX, y: e.clientY });
        }
      };

      // Add item - addAtEnd: true = bottom (click area), false = top (header click)
      const handleAddItem = (e, addAtEnd = true) => {
        e.stopPropagation();
        if (Date.now() - lastPopoverCloseTime < 200) return;
        const minSortOrder = dayItems.length > 0 ? Math.min(...dayItems.map(i => i.sortOrder || 0)) : 0;
        const maxSortOrder = dayItems.length > 0 ? Math.max(...dayItems.map(i => i.sortOrder || 0)) : 0;
        const sortOrder = addAtEnd ? maxSortOrder + 1 : minSortOrder - 1;
        onAdd({
          title: '',
          description: '',
          category: 'temp',
          effort: 1,
          repeat: null,
          scheduledDate: dateStr,
          scheduledSlot: 'todo',
          completed: false,
          completedDate: null,
          sortOrder,
          _isNewItem: true,
          _addAtEnd: addAtEnd,
        });
        setNewItemId('pending');
      };

      // Show edit popover once new item is rendered
      useEffect(() => {
        if (newItemId === 'pending') {
          const newestItem = dayItems.find(i => i._isNewItem);
          if (newestItem) {
            const timer = setTimeout(() => {
              if (newItemRef.current) {
                const rect = newItemRef.current.getBoundingClientRect();
                setEditRect({ itemId: newestItem.id, rect });
                setNewItemId(null);
              }
            }, 10);
            return () => clearTimeout(timer);
          }
        }
      }, [newItemId, dayItems]);

      const handleClosePopover = () => {
        setEditRect(null);
      };

      const editingItem = editRect ? dayItems.find(i => i.id === editRect.itemId) : null;

      // Header text color based on day type
      const getHeaderColor = () => {
        if (isToday) return 'var(--accent-blue)';
        if (day.isPast) return 'var(--text-past)';
        return 'var(--text-primary)';
      };

      // Mute past days when dragging recurring item (can't drop recurring items in the past)
      // Mute column if outside valid range for recurring item drag
      const isMutedForRecurring = (() => {
        if (draggingItemType !== 'recurring') return false;
        if (day.isPast) return true; // Always mute past days for recurring
        if (draggingRecurringRange) {
          const { minDate, maxDate } = draggingRecurringRange;
          if (minDate && dateStr < minDate) return true;
          if (maxDate && dateStr > maxDate) return true;
        }
        return false;
      })();

      return (
        <>
          <div
            ref={columnRef}
            onDragOver={isMutedForRecurring ? undefined : handleColumnDragOver}
            onDragLeave={handleDragLeave}
            onDrop={isMutedForRecurring ? undefined : handleDrop}
            style={{
              flex: (isSunday && !isSticky) ? `0 0 ${DAY_WIDTH + 12}px` : `0 0 ${DAY_WIDTH}px`,
              minWidth: (isSunday && !isSticky) ? `${DAY_WIDTH + 12}px` : `${DAY_WIDTH}px`,
              display: 'flex',
              flexDirection: 'column',
              borderRight: '1px solid var(--border-color)',
              borderLeft: (isSunday && !isSticky) ? `12px solid ${sundayLineColor}` : 'none',
              background: 'var(--bg-primary)',
              position: isSticky ? 'sticky' : 'relative',
              left: isSticky ? 0 : 'auto',
              zIndex: isSticky ? 10 : 1,
              boxShadow: isSticky ? '4px 0 10px rgba(0,0,0,0.1)' : 'none',
              opacity: isMutedForRecurring ? 0.3 : 1,
              pointerEvents: isMutedForRecurring ? 'none' : 'auto',
            }}>
            {/* Header - clickable to add at top */}
            <div
              onClick={(e) => handleAddItem(e, false)}
              className="column-header">
              <div style={{
                fontSize: '0.875rem',
                color: getHeaderColor(),
              }}>
                <span style={{ fontWeight: '700' }}>{formatDayNumber(day.date)}</span>
                {' '}
                <span style={{ fontWeight: '400' }}>{formatDayNameFull(day.date)}</span>
              </div>
              {isToday && (
                <span style={{
                  fontSize: '0.5rem',
                  fontWeight: '600',
                  color: 'var(--accent-blue)',
                }}>HOY</span>
              )}
            </div>

            {/* Items list - flex column to allow click area to expand */}
            <div className="column-items">
              {/* Drop indicator at top - only show if drop is valid */}
              <div className={`drop-indicator ${dropIndex === 0 && isDropValidAtIndex(0) ? 'visible' : ''}`} />
              {dayItems.map((item, index) => (
                <div
                  key={item.id}
                  ref={item._isNewItem ? newItemRef : null}
                  data-day-item="true"
                  onDragOver={(e) => handleItemDragOver(e, index)}
                  style={{ marginBottom: '0' }}
                  onClick={(e) => e.stopPropagation()}
                >
                  <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={onEdit} onDelete={onDelete} onToggleImportant={onToggleImportant} isToday={isToday} isPast={day.isPast} justDroppedItemId={justDroppedItemId} draggingItemType={draggingItemType} onDragTypeChange={onDragTypeChange} />
                  <div className={`drop-indicator ${dropIndex === index + 1 && isDropValidAtIndex(index + 1) ? 'visible' : ''}`} />
                </div>
              ))}
              {/* Click area to add at end - takes all remaining space */}
              <div onClick={(e) => handleAddItem(e, true)} className="column-click-area" />
            </div>
          </div>
          {editRect && editingItem && ReactDOM.createPortal(
            <AddEditItemPopover
              categories={categories}
              onSave={onAdd}
              onDelete={onDelete}
              onComplete={onComplete}
              onClose={handleClosePopover}
              targetRect={editRect.rect}
              editItem={editingItem}
            />,
            document.body
          )}
        </>
      );
    };

    const SidebarGroup = ({ label, count, items, expanded, onToggle, categories, onComplete, onEdit, onDrop, labelColor = 'var(--text-muted)', itemOpacity = 1, showDate = false, showDropIndicator = false, onAddItem, isBacklog = false, newItemRef, justDroppedItemId }) => {
      const [dropIndex, setDropIndex] = useState(-1);
      const groupRef = useRef(null);

      const hasItemData = (e) => Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata');

      const handleItemDragOver = (e, index) => {
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          const rect = e.currentTarget.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const isTopHalf = y < rect.height / 2;
          setDropIndex(isTopHalf ? index : index + 1);
        }
      };

      const handleGroupDragEnter = (e) => {
        if (hasItemData(e)) {
          e.stopPropagation();
          if (!expanded) {
            onToggle();
          }
          // Don't set dropIndex here - let handleGroupDragOver handle it
        }
      };

      const handleGroupDragOver = (e) => {
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          // Only update drop index if not over an item
          if (!e.target.closest('[data-sidebar-item]')) {
            const collapsible = groupRef.current?.querySelector('.collapsible');
            if (collapsible) {
              const itemElements = collapsible.querySelectorAll('[data-sidebar-item]');
              if (itemElements.length === 0) {
                setDropIndex(0);
              } else {
                // Check if cursor is below all items
                const lastItem = itemElements[itemElements.length - 1];
                const lastRect = lastItem.getBoundingClientRect();
                if (e.clientY > lastRect.bottom) {
                  setDropIndex(items.length);
                } else if (e.clientY < itemElements[0].getBoundingClientRect().top) {
                  setDropIndex(0);
                }
              }
            } else {
              setDropIndex(0);
            }
          }
        }
      };

      const handleDragLeave = (e) => {
        if (hasItemData(e)) {
          // Only reset if truly leaving the group
          if (groupRef.current && !groupRef.current.contains(e.relatedTarget)) {
            setDropIndex(-1);
          }
        }
      };

      const handleDrop = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const currentDropIndex = dropIndex;
        setDropIndex(-1);
        const data = e.dataTransfer.getData('itemData');
        if (data) onDrop(JSON.parse(data), currentDropIndex, e);
      };

      return (
        <div
          ref={groupRef}
          style={{ marginBottom: '4px' }}
          onDragEnter={handleGroupDragEnter}
          onDragOver={handleGroupDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
        >
          <div className="section-toggle section-toggle-content" onClick={(e) => { e.stopPropagation(); onToggle(); }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
              <span className="section-toggle-arrow" style={{ transform: expanded ? 'rotate(90deg)' : 'rotate(0)', color: labelColor }}>▶</span>
              <span className="section-toggle-label" style={{ color: labelColor }}>{label} ({count})</span>
            </div>
            {isBacklog && onAddItem && (
              <button onClick={(e) => { e.stopPropagation(); onAddItem(false); }} className="btn" style={{ fontWeight: '700', padding: '1px 5px', fontSize: '0.5625rem' }}><span className="btn-top-adjust">+</span></button>
            )}
          </div>
          <div className={`collapsible ${expanded ? 'expanded' : ''}`} style={{ paddingTop: '4px' }}>
            {/* Drop indicator at top - also show when dragging over parent category */}
            <div className={`drop-indicator ${dropIndex === 0 || showDropIndicator ? 'visible' : ''}`} />
            {items.map((item, index) => {
              const isLastItem = index === items.length - 1;
              const hasAgregarButton = isBacklog && onAddItem;
              // Last item has no marginBottom when there's Agregar button (button provides its own marginTop)
              const itemMargin = (hasAgregarButton && isLastItem) ? '0' : '6px';
              return (
                <div
                  key={item.id}
                  ref={item._isNewItem && newItemRef ? newItemRef : null}
                  data-sidebar-item="true"
                  onDragOver={(e) => handleItemDragOver(e, index)}
                  style={{ marginBottom: itemMargin, opacity: itemOpacity }}
                >
                  <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={onEdit} inSidebar={true} showDate={showDate} justDroppedItemId={justDroppedItemId} />
                  {/* Drop indicator - not after last item if there's an Agregar button */}
                  {!(hasAgregarButton && isLastItem) && (
                    <div className={`drop-indicator ${dropIndex === index + 1 ? 'visible' : ''}`} />
                  )}
                </div>
              );
            })}
            {/* Dashed Agregar button */}
            {isBacklog && onAddItem && (
              <button
                onClick={(e) => { e.stopPropagation(); onAddItem(true); }}
                className="btn-add-dashed"
                style={{ marginTop: '6px', marginBottom: '6px' }}
              >
                Agregar
              </button>
            )}
          </div>
        </div>
      );
    };

    const CategorySection = ({ category, items, allItems, categories, expanded, onToggle, onComplete, onEdit, onAdd, onDrop, onEditCategory, dragOverCat, onDelete, onSidebarGroupDrop, groupsExpandedState, justDroppedItemId, groupsExp, onGroupToggle, draggingUnscheduledItem, onScheduledItemClick }) => {
      const categoryItems = items.filter(i => i.category === category.id);

      // Get unique items (for repeating items, show only once based on repeatBaseId)
      const seenRepeatBaseIds = new Set();
      const seenIds = new Set();
      const uniqueItems = categoryItems.filter(item => {
        if (item.repeatBaseId) {
          if (seenRepeatBaseIds.has(item.repeatBaseId)) return false;
          seenRepeatBaseIds.add(item.repeatBaseId);
          return true;
        }
        const baseId = item.originalId || item.id;
        if (seenIds.has(baseId)) return false;
        seenIds.add(baseId);
        return true;
      });

      const ongoing = uniqueItems.filter(i => !i.completed && !i.isArchived);
      // Items without date (completed or not) stay in backlog in place
      const doneItems = uniqueItems.filter(i => i.completed && !i.hiddenFromSidebar && i.scheduledDate)
        .sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

      // Backlog = archived items + items without scheduled date (including completed, excluding recurring items)
      const backlogItems = uniqueItems.filter(i => (i.isArchived || !i.scheduledDate) && !i.repeat)
        .sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
      // Scheduled = items with scheduledDate OR recurring items
      const scheduled = ongoing.filter(i => i.scheduledDate || i.repeat);
      // Separate recurring items (no scheduledDate) from date-scheduled items
      const recurringItems = scheduled.filter(i => i.repeat && !i.scheduledDate);
      const dateScheduled = scheduled.filter(i => i.scheduledDate);

      // Group date-scheduled by date and sort
      const byDate = {};
      dateScheduled.forEach(item => {
        if (!byDate[item.scheduledDate]) byDate[item.scheduledDate] = [];
        byDate[item.scheduledDate].push(item);
      });
      const sortedDates = Object.keys(byDate).sort();

      const scheduledCount = uniqueItems.filter(i => i.scheduledDate && !i.completed && !i.repeat).length;

      // Use props for group expansion state (managed by App for persistence)
      const scheduledExp = groupsExp?.scheduled ?? true;
      const backlogExp = groupsExp?.backlog ?? true;
      const doneExp = groupsExp?.done ?? true;

      const [addRect, setAddRect] = useState(null);
      const [removeDatePopover, setRemoveDatePopover] = useState(null);
      const [editCatRect, setEditCatRect] = useState(null);
      const [dragging, setDragging] = useState(false);
      const [isDraggingItem, setIsDraggingItem] = useState(false);
      const [newBacklogItemId, setNewBacklogItemId] = useState(null);
      const [backlogEditRect, setBacklogEditRect] = useState(null);
      const newBacklogItemRef = useRef(null);
      const contentRef = useRef(null);
      const expandTimeoutRef = useRef(null);

      const handleCategoryDoubleClick = (e) => {
        if (category.isFixed) return;
        e.stopPropagation();
        setEditCatRect(e.currentTarget.getBoundingClientRect());
      };

      // Create item in backlog - addAtEnd determines position
      const handleBacklogAddItem = (addAtEnd) => {
        // Don't create if a popover was just closed
        if (Date.now() - lastPopoverCloseTime < 200) return;
        // Prevent ghost items from double-click
        if (newBacklogItemId !== null || backlogEditRect) return;
        // Make sure backlog is expanded
        if (!backlogExp) setBacklogExp(true);
        // Calculate sortOrder
        const minSortOrder = backlogItems.length > 0 ? Math.min(...backlogItems.map(i => i.sortOrder || 0)) : 0;
        const maxSortOrder = backlogItems.length > 0 ? Math.max(...backlogItems.map(i => i.sortOrder || 0)) : 0;
        const sortOrder = addAtEnd ? maxSortOrder + 1 : minSortOrder - 1;
        onAdd({
          title: '',
          description: '',
          category: category.id,
          effort: 1,
          repeat: null,
          scheduledDate: null,
          scheduledSlot: null,
          completed: false,
          completedDate: null,
          sortOrder,
          isArchived: true,
          _isNewItem: true,
          _addAtEnd: addAtEnd,
        });
        setNewBacklogItemId('pending');
      };

      // Show edit popover once new backlog item is rendered
      useEffect(() => {
        if (newBacklogItemId === 'pending') {
          const newestItem = backlogItems.find(i => i._isNewItem);
          if (newestItem) {
            const timer = setTimeout(() => {
              if (newBacklogItemRef.current) {
                const rect = newBacklogItemRef.current.getBoundingClientRect();
                setBacklogEditRect({ itemId: newestItem.id, rect });
                setNewBacklogItemId(null);
              } else {
                setTimeout(() => {
                  if (newBacklogItemRef.current) {
                    const rect = newBacklogItemRef.current.getBoundingClientRect();
                    setBacklogEditRect({ itemId: newestItem.id, rect });
                  }
                  setNewBacklogItemId(null);
                }, 50);
              }
            }, 10);
            return () => clearTimeout(timer);
          }
        }
      }, [newBacklogItemId, backlogItems]);

      const handleBacklogClosePopover = () => {
        setBacklogEditRect(null);
      };

      const backlogEditingItem = backlogEditRect ? backlogItems.find(i => i.id === backlogEditRect.itemId) : null;

      // Handle dropping on sidebar groups
      const handleGroupDrop = (data, targetGroup, e, dropIdx) => {
        const { id, isRecurring, originalDate, title } = data;
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : parseInt(id);
        const item = allItems.find(i => i.id === numId);

        if (!item) return;

        // Don't allow recurring items to be moved to categories at all
        if (item.repeat) return;

        // Move directly without confirmation
        onSidebarGroupDrop?.(numId, targetGroup, category.id, dropIdx);
      };

      // Category itself is not draggable if fixed, but items inside are always draggable
      const isCategoryDraggable = !category.isFixed;

      // Track drag enter count to handle nested elements
      const dragCountRef = useRef(0);

      // Handle auto-expand when dragging over closed category
      const handleCategoryDragEnter = (e) => {
        // Check if dragging an item (not a category)
        if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
          dragCountRef.current++;
          setIsDraggingItem(true);
          // Only start timer on first enter and if not expanded
          if (dragCountRef.current === 1 && !expanded && !expandTimeoutRef.current) {
            expandTimeoutRef.current = setTimeout(() => {
              onToggle();
              expandTimeoutRef.current = null;
            }, 400);
          }
        }
      };

      const handleCategoryDragLeave = (e) => {
        if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
          dragCountRef.current--;
          // Only clear when truly leaving (count reaches 0)
          if (dragCountRef.current === 0) {
            if (expandTimeoutRef.current) {
              clearTimeout(expandTimeoutRef.current);
              expandTimeoutRef.current = null;
            }
            setIsDraggingItem(false);
          }
        }
      };

      const handleCategoryDrop = (e) => {
        e.preventDefault();
        dragCountRef.current = 0;
        if (expandTimeoutRef.current) {
          clearTimeout(expandTimeoutRef.current);
          expandTimeoutRef.current = null;
        }
        setIsDraggingItem(false);
        const data = e.dataTransfer.getData('itemData');
        if (data) {
          const parsed = JSON.parse(data);
          // Don't allow recurring items to be moved to categories
          if (parsed.isRecurring) return;
          // Drop on category goes to "anyday" by default
          handleGroupDrop(parsed, 'anyday', e);
        }
      };

      return (
        <div
          className={dragging ? 'dragging' : ''}
          onDragEnter={handleCategoryDragEnter}
          onDragLeave={handleCategoryDragLeave}
          onDragOver={(e) => { if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) e.preventDefault(); }}
          onDrop={handleCategoryDrop}
          style={{ background: 'var(--bg-sidebar)', borderBottom: '1px solid var(--border-color)', outline: dragOverCat === category.id ? '2px dashed var(--accent-blue)' : 'none' }}>
          <div className="category-heading" draggable={isCategoryDraggable}
            onDragStart={(e) => { if (!isCategoryDraggable) { e.preventDefault(); return; } e.dataTransfer.setData('categoryId', category.id); setDragging(true); }}
            onDragEnd={() => setDragging(false)}
            onClick={onToggle} style={{ display: 'flex', alignItems: 'center', padding: '10px', minHeight: '36px', background: expanded ? `${category.color}12` : 'transparent' }}>
            <div className="cat-swatch" style={{ background: category.color }} />
            <span onDoubleClick={handleCategoryDoubleClick} className="cat-name" style={{ color: category.color }}>{category.name} ({ongoing.length})</span>
            <span style={{ color: 'var(--text-muted)', transform: expanded ? 'rotate(180deg)' : 'rotate(0)', transition: 'transform 0.2s', fontSize: '0.625rem', padding: '4px' }}>▼</span>
          </div>
          <div className={`collapsible ${expanded ? 'expanded' : ''}`}>
            <div ref={contentRef} style={{ padding: '6px 10px 8px' }}>
              {/* Backlog section - includes all non-scheduled items */}
              <SidebarGroup
                label="Backlog"
                count={backlogItems.length}
                items={backlogItems}
                expanded={backlogExp}
                onToggle={() => onGroupToggle?.('backlog')}
                categories={categories}
                onComplete={onComplete}
                onEdit={onEdit}
                onDrop={(data, dropIdx, e) => handleGroupDrop(data, 'backlog', e, dropIdx)}
                showDropIndicator={isDraggingItem}
                isBacklog={true}
                onAddItem={handleBacklogAddItem}
                newItemRef={newBacklogItemRef}
                justDroppedItemId={justDroppedItemId}
              />

              {/* Scheduled - Agendado - cursor not-allowed on drag over */}
              <div
                style={{ marginBottom: '4px', cursor: 'inherit', opacity: draggingUnscheduledItem ? 0.4 : 1, pointerEvents: draggingUnscheduledItem ? 'none' : 'auto', transition: 'opacity 0.15s' }}
                onDragOver={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'none'; }}
                onDragEnter={(e) => { e.currentTarget.style.cursor = 'not-allowed'; }}
                onDragLeave={(e) => { e.currentTarget.style.cursor = 'inherit'; }}
              >
                <div className="section-toggle section-toggle-content" onClick={(e) => { e.stopPropagation(); onGroupToggle?.('scheduled'); }} style={{ justifyContent: 'flex-start', gap: '4px' }}>
                  <span className="section-toggle-arrow" style={{ transform: scheduledExp ? 'rotate(90deg)' : 'rotate(0)', color: 'var(--text-muted)' }}>▶</span>
                  <span className="section-toggle-label" style={{ color: 'var(--text-muted)' }}>Agendado ({scheduled.length})</span>
                </div>
                <div className={`collapsible ${scheduledExp ? 'expanded' : ''}`}>
                  {recurringItems.map(item => (
                    <div key={item.id} style={{ marginBottom: '6px', cursor: 'pointer' }} onClick={() => onScheduledItemClick?.(allItems.find(i => i.id === item.id) || item)}>
                      <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={() => {}} inSidebar={true} showDate={true} justDroppedItemId={justDroppedItemId} />
                    </div>
                  ))}
                  {sortedDates.flatMap(date => byDate[date]).map(item => (
                    <div key={item.id} style={{ marginBottom: '6px', cursor: 'pointer' }} onClick={() => onScheduledItemClick?.(allItems.find(i => i.id === (item.originalId || item.id)) || item)}>
                      <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={() => {}} inSidebar={true} showDate={true} justDroppedItemId={justDroppedItemId} />
                    </div>
                  ))}
                </div>
              </div>

            </div>
          </div>
          {backlogEditRect && backlogEditingItem && ReactDOM.createPortal(
            <AddEditItemPopover
              categories={categories}
              onSave={onAdd}
              onDelete={onDelete}
              onComplete={onComplete}
              onClose={handleBacklogClosePopover}
              targetRect={backlogEditRect.rect}
              editItem={backlogEditingItem}
            />,
            document.body
          )}
          {editCatRect && <EditCategoryPopover category={category} itemCount={items.filter(i => i.category === category.id).length} onSave={onEditCategory} onDelete={() => {}} onClose={() => setEditCatRect(null)} targetRect={editCatRect} />}
          {removeDatePopover && <RemoveDatePopover
            itemTitle={removeDatePopover.item.title}
            isRecurring={removeDatePopover.isRecurring}
            onConfirm={() => {
              onSidebarGroupDrop?.(removeDatePopover.item.id, 'backlog', category.id, removeDatePopover.dropIdx);
              setRemoveDatePopover(null);
            }}
            onCancel={() => setRemoveDatePopover(null)}
            targetRect={removeDatePopover.rect}
          />}
        </div>
      );
    };

    // ============ EXPANDED CATEGORIES COLUMN ============

    const ExpandedCategoryColumn = ({ category, items, allItems, categories, onComplete, onEdit, onAdd, onDrop, onEditCategory, onDelete, onSidebarGroupDrop, justDroppedItemId, groupsExp, onGroupToggle, draggingUnscheduledItem, onScheduledItemClick }) => {
      const categoryItems = items.filter(i => i.category === category.id);

      const seenRepeatBaseIds = new Set();
      const seenIds = new Set();
      const uniqueItems = categoryItems.filter(item => {
        if (item.repeatBaseId) {
          if (seenRepeatBaseIds.has(item.repeatBaseId)) return false;
          seenRepeatBaseIds.add(item.repeatBaseId);
          return true;
        }
        const baseId = item.originalId || item.id;
        if (seenIds.has(baseId)) return false;
        seenIds.add(baseId);
        return true;
      });

      const ongoing = uniqueItems.filter(i => !i.completed && !i.isArchived);
      // Items without date (completed or not) stay in backlog in place
      const doneItems = uniqueItems.filter(i => i.completed && !i.hiddenFromSidebar && i.scheduledDate)
        .sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

      // Backlog = archived items + items without scheduled date (including completed, excluding recurring items)
      const backlogItems = uniqueItems.filter(i => (i.isArchived || !i.scheduledDate) && !i.repeat)
        .sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
      const scheduled = ongoing.filter(i => i.scheduledDate || i.repeat);
      const recurringItems = scheduled.filter(i => i.repeat && !i.scheduledDate);
      const dateScheduled = scheduled.filter(i => i.scheduledDate);

      const byDate = {};
      dateScheduled.forEach(item => {
        if (!byDate[item.scheduledDate]) byDate[item.scheduledDate] = [];
        byDate[item.scheduledDate].push(item);
      });
      const sortedDates = Object.keys(byDate).sort();

      const scheduledExp = groupsExp?.scheduled ?? true;
      const backlogExp = groupsExp?.backlog ?? true;
      const doneExp = groupsExp?.done ?? true;

      const [isDraggingItem, setIsDraggingItem] = useState(false);
      const [isDraggingUnscheduledItem, setIsDraggingUnscheduledItem] = useState(false);
      const [removeDatePopover, setRemoveDatePopover] = useState(null);
      const [editCatRect, setEditCatRect] = useState(null);
      const [isDraggingColumn, setIsDraggingColumn] = useState(false);
      const dragCountRef = useRef(0);

      const handleCategoryDoubleClick = (e) => {
        if (category.isFixed) return;
        e.stopPropagation();
        setEditCatRect(e.currentTarget.getBoundingClientRect());
      };

      const isCategoryDraggable = !category.isFixed;

      const handleGroupDrop = (data, targetGroup, e, dropIdx) => {
        const { id } = data;
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : parseInt(id);
        const item = allItems.find(i => i.id === numId);
        if (!item) return;

        // Don't allow recurring items to be moved to categories at all
        if (item.repeat) return;

        // Move directly without confirmation
        onSidebarGroupDrop?.(numId, targetGroup, category.id, dropIdx);
      };

      const handleColumnDragEnter = (e) => {
        if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
          dragCountRef.current++;
          setIsDraggingItem(true);
          // Check if dragged item is unscheduled (no date and no repeat)
          try {
            const data = e.dataTransfer.getData('itemData');
            if (data) {
              const parsed = JSON.parse(data);
              if (!parsed.visualDate && !parsed.isRecurring) {
                setIsDraggingUnscheduledItem(true);
              }
            }
          } catch (err) {
            // dataTransfer might not be available during dragenter in some browsers
          }
        }
      };

      const handleColumnDragLeave = (e) => {
        if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
          dragCountRef.current--;
          if (dragCountRef.current === 0) {
            setIsDraggingItem(false);
            setIsDraggingUnscheduledItem(false);
          }
        }
      };

      const handleColumnDrop = (e) => {
        e.preventDefault();
        dragCountRef.current = 0;
        setIsDraggingItem(false);
        setIsDraggingUnscheduledItem(false);
        const data = e.dataTransfer.getData('itemData');
        if (data) {
          const parsed = JSON.parse(data);
          // Don't allow recurring items to be moved to categories
          if (parsed.isRecurring) return;
          handleGroupDrop(parsed, 'anyday', e);
        }
      };

      return (
        <div
          onDragEnter={handleColumnDragEnter}
          onDragLeave={handleColumnDragLeave}
          onDragOver={(e) => { if (Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) e.preventDefault(); }}
          onDrop={handleColumnDrop}
          style={{ flex: '0 0 300px', width: '300px', display: 'flex', flexDirection: 'column', background: 'var(--bg-sidebar)', borderRight: '1px solid var(--border-color)', height: '100%' }}>
          <div
            draggable={isCategoryDraggable}
            onDragStart={(e) => { if (!isCategoryDraggable) { e.preventDefault(); return; } e.dataTransfer.setData('expandedCategoryId', category.id); setIsDraggingColumn(true); }}
            onDragEnd={() => setIsDraggingColumn(false)}
            style={{ padding: '10px', borderBottom: '1px solid var(--border-color)', display: 'flex', alignItems: 'center', minHeight: '36px', background: `${category.color}12`, cursor: isCategoryDraggable ? 'grab' : 'default', opacity: isDraggingColumn ? 0.5 : 1 }}>
            <div className="cat-swatch" style={{ background: category.color }} />
            <span onDoubleClick={handleCategoryDoubleClick} className="cat-name" style={{ color: category.color }}>{category.name} ({ongoing.length})</span>
          </div>
          <div style={{ flex: 1, overflowY: 'auto', padding: '6px 10px 8px' }}>
            <SidebarGroup label="Backlog" count={backlogItems.length} items={backlogItems} expanded={backlogExp} onToggle={() => onGroupToggle?.('backlog')} categories={categories} onComplete={onComplete} onEdit={onEdit} onDrop={(data, dropIdx, e) => handleGroupDrop(data, 'backlog', e, dropIdx)} showDropIndicator={isDraggingItem} isBacklog={true} justDroppedItemId={justDroppedItemId} />
            <div style={{ marginBottom: '4px', opacity: draggingUnscheduledItem ? 0.4 : 1, pointerEvents: draggingUnscheduledItem ? 'none' : 'auto', transition: 'opacity 0.15s' }} onDragOver={(e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'none'; }}>
              <div className="section-toggle section-toggle-content" onClick={(e) => { e.stopPropagation(); onGroupToggle?.('scheduled'); }} style={{ justifyContent: 'flex-start', gap: '4px' }}>
                <span className="section-toggle-arrow" style={{ transform: scheduledExp ? 'rotate(90deg)' : 'rotate(0)', color: 'var(--text-muted)' }}>▶</span>
                <span className="section-toggle-label" style={{ color: 'var(--text-muted)' }}>Agendado ({scheduled.length})</span>
              </div>
              <div className={`collapsible ${scheduledExp ? 'expanded' : ''}`}>
                {recurringItems.map(item => (
                  <div key={item.id} style={{ marginBottom: '6px', cursor: 'pointer' }} onClick={() => onScheduledItemClick?.(allItems.find(i => i.id === item.id) || item)}>
                    <ItemCard item={item} categories={categories} onEdit={() => {}} inSidebar={true} showDate={true} justDroppedItemId={justDroppedItemId} />
                  </div>
                ))}
                {sortedDates.flatMap(date => byDate[date]).map(item => (
                  <div key={item.id} style={{ marginBottom: '6px', cursor: 'pointer' }} onClick={() => onScheduledItemClick?.(allItems.find(i => i.id === (item.originalId || item.id)) || item)}>
                    <ItemCard item={item} categories={categories} onEdit={() => {}} inSidebar={true} showDate={true} justDroppedItemId={justDroppedItemId} />
                  </div>
                ))}
              </div>
            </div>
          </div>
          {removeDatePopover && <RemoveDatePopover itemTitle={removeDatePopover.item.title} isRecurring={removeDatePopover.isRecurring} onConfirm={() => { onSidebarGroupDrop?.(removeDatePopover.item.id, 'backlog', category.id, removeDatePopover.dropIdx); setRemoveDatePopover(null); }} onCancel={() => setRemoveDatePopover(null)} targetRect={removeDatePopover.rect} />}
          {editCatRect && <EditCategoryPopover category={category} itemCount={items.filter(i => i.category === category.id).length} onSave={onEditCategory} onDelete={() => {}} onClose={() => setEditCatRect(null)} targetRect={editCatRect} />}
        </div>
      );
    };

    // ============ SIMPLIFIED CATEGORY COLUMN (for two-row layout) ============
    const CategoryColumnSimple = ({ category, items, allItems, categories, onComplete, onEdit, onAdd, onDrop, onEditCategory, onDelete, onToggleImportant, onSidebarGroupDrop, justDroppedItemId, draggingItemType, onDragTypeChange }) => {
      const categoryItems = items.filter(i => i.category === category.id);

      // Get backlog items (no scheduledDate, not recurring) - includes completed items
      const backlogItems = categoryItems.filter(i =>
        !i.scheduledDate && !i.isArchived && !i.repeat
      ).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

      const [dropIndex, setDropIndex] = useState(-1);
      const [isDraggingColumn, setIsDraggingColumn] = useState(false);
      const [removeDatePopover, setRemoveDatePopover] = useState(null);
      const [newItemId, setNewItemId] = useState(null);
      const [editRect, setEditRect] = useState(null);
      const columnRef = useRef(null);
      const newItemRef = useRef(null);

      const isCategoryDraggable = !category.isFixed;

      // Show edit popover once new item is rendered
      useEffect(() => {
        if (newItemId === 'pending') {
          const newestItem = backlogItems.find(i => i._isNewItem);
          if (newestItem) {
            const timer = setTimeout(() => {
              if (newItemRef.current) {
                const rect = newItemRef.current.getBoundingClientRect();
                setEditRect({ itemId: newestItem.id, rect });
                setNewItemId(null);
              }
            }, 50);
            return () => clearTimeout(timer);
          }
        }
      }, [newItemId, backlogItems]);

      const hasItemData = (e) => Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata');

      const handleItemDragOver = (e, index) => {
        // Don't allow recurring items to be dropped in categories
        if (draggingItemType === 'recurring') return;
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          const rect = e.currentTarget.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const isTopHalf = y < rect.height / 2;
          setDropIndex(isTopHalf ? index : index + 1);
        }
      };

      const handleColumnDragOver = (e) => {
        // Don't allow recurring items to be dropped in categories
        if (draggingItemType === 'recurring') return;
        if (hasItemData(e)) {
          e.preventDefault();
          if (!e.target.closest('[data-backlog-item]')) {
            setDropIndex(backlogItems.length);
          }
        }
      };

      const handleDragLeave = (e) => {
        if (columnRef.current && !columnRef.current.contains(e.relatedTarget)) {
          setDropIndex(-1);
        }
      };

      const handleDrop = (e) => {
        e.preventDefault();
        const currentDropIndex = dropIndex;
        setDropIndex(-1);
        onDragTypeChange?.(null); // Reset mute state on drop
        const data = e.dataTransfer.getData('itemData');
        if (data) {
          const parsed = JSON.parse(data);
          const { id, isRecurring } = parsed;

          // Don't allow recurring items to be dropped in categories - silently ignore
          if (isRecurring) return;

          const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : parseInt(id);
          const item = allItems.find(i => i.id === numId);

          // Double check - if item is recurring, don't allow
          if (item?.repeat) return;

          // Move directly without confirmation
          onSidebarGroupDrop?.(numId, 'backlog', category.id, currentDropIndex);
        }
      };

      // Add item to backlog
      const handleAddItem = (addAtEnd = true) => {
        if (Date.now() - lastPopoverCloseTime < 200) return;
        // Prevent ghost items from double-click: don't create if one is already pending
        if (newItemId !== null || editRect) return;
        const minSortOrder = backlogItems.length > 0 ? Math.min(...backlogItems.map(i => i.sortOrder || 0)) : 0;
        const maxSortOrder = backlogItems.length > 0 ? Math.max(...backlogItems.map(i => i.sortOrder || 0)) : 0;
        const sortOrder = addAtEnd ? maxSortOrder + 1 : minSortOrder - 1;
        onAdd({
          title: '',
          description: '',
          category: category.id,
          effort: 1,
          repeat: null,
          scheduledDate: null,
          scheduledSlot: null,
          completed: false,
          completedDate: null,
          sortOrder,
          _isNewItem: true,
          _addAtEnd: addAtEnd,
        });
        setNewItemId('pending');
      };

      // Mute category column when dragging recurring items (can't drop recurring in categories)
      const isMutedForRecurring = draggingItemType === 'recurring';

      return (
        <div
          ref={columnRef}
          onDragOver={handleColumnDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          style={{
            flex: `0 0 ${CATEGORY_WIDTH}px`,
            width: `${CATEGORY_WIDTH}px`,
            display: 'flex',
            flexDirection: 'column',
            borderRight: '1px solid var(--border-color)',
            height: '100%',
            background: 'var(--bg-header)',
            opacity: isMutedForRecurring ? 0.3 : 1,
            pointerEvents: isMutedForRecurring ? 'none' : 'auto',
          }}>
          {/* Category header - clickable to add item */}
          <div
            draggable={isCategoryDraggable}
            onDragStart={(e) => {
              if (!isCategoryDraggable) { e.preventDefault(); return; }
              e.dataTransfer.setData('categoryId', category.id);
              setIsDraggingColumn(true);
            }}
            onDragEnd={() => setIsDraggingColumn(false)}
            onClick={(e) => { e.stopPropagation(); handleAddItem(false); }}
            className="column-header"
            style={{ alignItems: 'center', opacity: isDraggingColumn ? 0.5 : 1 }}>
            <div style={{ fontSize: '0.875rem', color: category.color }}>
              <span style={{ fontWeight: '700' }}>{category.name}</span>
              <span style={{ fontWeight: '400', opacity: 0.7 }}> ({backlogItems.length})</span>
            </div>
          </div>

          {/* Items list - flex column to allow click area to expand */}
          <div className="column-items">
            {/* Drop indicator at top */}
            <div className={`drop-indicator ${dropIndex === 0 ? 'visible' : ''}`} />
            {backlogItems.map((item, index) => {
              const isNewItem = item._isNewItem;
              const editingItem = editRect?.itemId === item.id ? item : null;
              return (
                <div
                  key={item.id}
                  ref={isNewItem ? newItemRef : null}
                  data-backlog-item="true"
                  onDragOver={(e) => handleItemDragOver(e, index)}
                  style={{ marginBottom: '0' }}
                >
                  <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={onEdit} onDelete={onDelete} onToggleImportant={onToggleImportant} inSidebar={true} justDroppedItemId={justDroppedItemId} draggingItemType={draggingItemType} onDragTypeChange={onDragTypeChange} />
                  <div className={`drop-indicator ${dropIndex === index + 1 ? 'visible' : ''}`} />
                </div>
              );
            })}
            {/* Click area to add at end - takes all remaining space */}
            <div onClick={() => handleAddItem(true)} className="column-click-area" />
          </div>

          {/* Edit popover for new items */}
          {editRect && (
            <AddEditItemPopover
              categories={categories}
              editItem={backlogItems.find(i => i.id === editRect.itemId)}
              onSave={(data) => {
                onAdd(data);
                setEditRect(null);
              }}
              onDelete={(id) => {
                onDelete(id);
                setEditRect(null);
              }}
              onClose={() => {
                setEditRect(null);
              }}
              targetRect={editRect.rect}
            />
          )}

          {removeDatePopover && (
            <RemoveDatePopover
              itemTitle={removeDatePopover.item.title}
              isRecurring={removeDatePopover.isRecurring}
              onConfirm={() => {
                onSidebarGroupDrop?.(removeDatePopover.item.id, 'backlog', category.id, removeDatePopover.dropIdx);
                setRemoveDatePopover(null);
              }}
              onCancel={() => setRemoveDatePopover(null)}
              targetRect={removeDatePopover.rect}
            />
          )}
        </div>
      );
    };

    // ============ MOBILE COMPONENTS ============

    // BottomSheet for mobile item editing
    const BottomSheet = ({ item, visualDate, categories, onSave, onDelete, onComplete, onToggleImportant, onDuplicate, onClose, closing }) => {
      const [title, setTitle] = useState(item?.title || '');
      const [description, setDescription] = useState(item?.description || '');
      const [category, setCategory] = useState(item?.category || 'temp');
      const [effort, setEffort] = useState(item?.effort ?? 1);
      const initialDate = item?.scheduledDate || visualDate || null;
      const [scheduledDate, setScheduledDate] = useState(initialDate);
      const [scheduledSlot, setScheduledSlot] = useState(item?.scheduledSlot || 'todo');
      const [repeatType, setRepeatType] = useState(item?.repeat?.type || 'none');
      const [repeatEvery, setRepeatEvery] = useState(item?.repeat?.every || 1);
      const [repeatDays, setRepeatDays] = useState(item?.repeat?.days || []);
      const [repeatMode, setRepeatMode] = useState(item?.repeat?.mode || 'fixed');
      const [showDatePicker, setShowDatePicker] = useState(false);
      const [showDiscardDialog, setShowDiscardDialog] = useState(false);
      const [userClearedDate, setUserClearedDate] = useState(false);
      const inputRef = useRef(null);

      const isEditing = !!item?.id && !item._isNewItem;
      const hadRepeat = !!item?.repeat;
      const originalTitle = item?.title || '';
      const originalDescription = item?.description || '';

      // Compute valid date range for recurring items (Outlook restriction)
      const validDateRange = useMemo(() => {
        if (!item?.repeat || !visualDate) return null;
        return getValidMoveRange(item, visualDate);
      }, [item, visualDate]);

      // Check if this is a new item created with empty title (from FAB click)
      const isNewUntitledItem = !!item?._isNewItem || (!!item?.id && originalTitle === '');

      // Auto-focus for new items - use autoFocus attribute instead of programmatic focus
      // Safari iOS blocks programmatic focus() outside of direct user interaction

      const hasChanges = title !== originalTitle || description !== originalDescription ||
        category !== (item?.category || 'temp') || effort !== (item?.effort ?? 1) ||
        scheduledDate !== initialDate || scheduledSlot !== (item?.scheduledSlot || 'todo') ||
        repeatType !== (item?.repeat?.type || 'none') || repeatMode !== (item?.repeat?.mode || 'fixed');

      const hasUserChanges = isNewUntitledItem ? (
        title.trim() !== '' || description !== '' || category !== (item?.category || 'temp') ||
        effort !== 1 || repeatType !== 'none'
      ) : hasChanges;

      const handleRequestClose = () => {
        if (hasUserChanges && (title.trim() || isEditing)) {
          setShowDiscardDialog(true);
        } else {
          if (isNewUntitledItem) onDelete(item.id);
          lastPopoverCloseTime = Date.now();
          onClose();
        }
      };

      const handleSave = () => {
        if (!title.trim()) {
          if (isNewUntitledItem) onDelete(item.id);
          lastPopoverCloseTime = Date.now();
          onClose();
          return;
        }
        let repeat = null;
        if (repeatType === 'weekdays') repeat = { type: 'weekdays', days: repeatDays };
        else if (repeatType !== 'none') repeat = { type: repeatType, every: repeatEvery, mode: repeatMode };

        let finalScheduledDate = scheduledDate;
        if (hadRepeat && !repeat && !scheduledDate && visualDate && !userClearedDate) {
          finalScheduledDate = visualDate;
        }

        lastPopoverCloseTime = Date.now();
        onSave({
          id: item?.id,
          title: title.trim(),
          description,
          category,
          effort,
          repeat,
          scheduledDate: finalScheduledDate,
          scheduledSlot: (finalScheduledDate || repeat) ? scheduledSlot : null,
          completed: item?.completed || false,
          completedDate: item?.completedDate || null,
          isArchived: false, // Items without date go to backlog, not archived
          sortOrder: item?.sortOrder ?? 0,
        });
      };

      const toggleDay = (d) => setRepeatDays(p => p.includes(d) ? p.filter(x => x !== d) : [...p, d]);

      const getDateLabel = () => {
        if (!scheduledDate) return 'Sin fecha';
        return formatDateLabel(scheduledDate);
      };

      return (
        <>
          <div className={`bottom-sheet-overlay ${closing ? 'closing' : ''}`} onClick={handleRequestClose} />
          <div className={`bottom-sheet ${closing ? 'closing' : ''}`}>
            {/* Sticky header */}
            <div className="bs-header">
              <button
                onClick={handleRequestClose}
                className="btn"
                style={{ fontSize: '0.75rem', padding: '8px 16px' }}
              >
                Cancelar
              </button>
              <button
                onClick={handleSave}
                disabled={!title.trim()}
                className="btn btn-primary"
                style={{ padding: '8px 16px', fontSize: '0.75rem', opacity: title.trim() ? 1 : 0.5 }}
              >
                {isEditing ? 'Guardar' : 'Agregar'}
              </button>
            </div>

            <input
              ref={inputRef}
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              placeholder="Item..."
              autoFocus={isNewUntitledItem}
              className="form-control form-group"
              style={{ padding: '12px', fontSize: '0.875rem' }}
            />

            <textarea
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              placeholder="Descripción..."
              rows={2}
              className="form-control form-group form-textarea"
              style={{ padding: '12px', fontSize: '0.75rem' }}
            />

            <select
              value={category}
              onChange={(e) => setCategory(e.target.value)}
              className="form-control form-group"
              style={{ padding: '10px', fontSize: '0.75rem' }}
            >
              {categories.map(c => <option key={c.id} value={c.id}>{c.name}</option>)}
            </select>

            <div className="form-group-lg">
              <div className="form-label">Fecha</div>
              <button
                onClick={() => setShowDatePicker(!showDatePicker)}
                className="form-control"
                style={{
                  padding: '10px', borderRadius: '8px',
                  color: scheduledDate ? 'var(--text-primary)' : 'var(--text-muted)',
                  fontSize: '0.75rem', textAlign: 'left', cursor: 'pointer'
                }}
              >
                {getDateLabel()}
              </button>
              {showDatePicker && (
                <div style={{ marginTop: '8px' }}>
                  <MiniCalendar selectedDate={scheduledDate} onSelect={(date) => { setScheduledDate(date); if (!date) { setRepeatType('none'); setUserClearedDate(true); } }} onClose={() => setShowDatePicker(false)} validDateRange={validDateRange} />
                </div>
              )}
            </div>

            {hadRepeat && userClearedDate && (
              <div className="warning-box form-group-lg">
                Al guardar se eliminará la recurrencia
              </div>
            )}

            {/* Only show repeat options if there's a date */}
            {scheduledDate && (
              <div className="form-group-lg">
                <div className="form-label">Repetir</div>
                <select value={repeatType} onChange={(e) => setRepeatType(e.target.value)} className="form-control" style={{ padding: '10px', borderRadius: '8px', fontSize: '0.75rem' }}>
                  <option value="none">No repetir</option>
                  <option value="days">Cada X días</option>
                  <option value="weeks">Cada X semanas</option>
                  <option value="weekdays">Días de semana</option>
                </select>
                {repeatType !== 'none' && repeatType !== 'weekdays' && (
                  <>
                    <input type="number" min="1" max="30" value={repeatEvery} onChange={(e) => setRepeatEvery(parseInt(e.target.value) || 1)}
                      className="form-control" style={{ marginTop: '6px', padding: '10px', borderRadius: '8px', fontSize: '0.75rem', textAlign: 'center' }}
                    />
                    {repeatType === 'days' && (
                      <select value={repeatMode} onChange={(e) => setRepeatMode(e.target.value)} className="form-control" style={{ marginTop: '6px', padding: '10px', borderRadius: '8px', fontSize: '0.625rem', color: 'var(--text-muted)' }}>
                        <option value="fixed">Desde fecha fija</option>
                        <option value="completion">Desde última completación</option>
                      </select>
                    )}
                  </>
                )}
                {repeatType === 'weekdays' && (
                  <div style={{ display: 'flex', gap: '4px', marginTop: '6px' }}>
                    {DAYS.map((d, i) => (
                      <button key={i} type="button" onClick={() => toggleDay(i)} className={repeatDays.includes(i) ? 'btn btn-primary' : 'btn'} style={{ flex: 1, padding: '8px 4px', fontSize: '0.625rem' }}>{d.charAt(0)}</button>
                    ))}
                  </div>
                )}
              </div>
            )}

            {/* Bottom actions - mobile only: important and complete buttons */}
            {isEditing && (
              <div style={{ display: 'flex', gap: '8px', alignItems: 'center', marginTop: '12px', marginBottom: '8px' }}>
                {/* Important button - doesn't close popover */}
                {!item.repeat && (
                  <button
                    type="button"
                    onClick={() => onToggleImportant?.(item.id)}
                    className="bs-action-btn"
                    style={{
                      background: item.isImportant ? 'var(--accent-yellow)' : 'var(--bg-button)',
                      color: item.isImportant ? 'white' : 'var(--text-secondary)',
                    }}
                  >
                    <svg width="16" height="16" viewBox="0 0 24 24" fill={item.isImportant ? 'white' : 'none'} stroke="currentColor" strokeWidth="2">
                      <circle cx="12" cy="12" r="10"/>
                      <line x1="12" y1="8" x2="12" y2="12"/>
                      <line x1="12" y1="16" x2="12.01" y2="16"/>
                    </svg>
                    Importante
                  </button>
                )}
                {/* Complete button - saves and closes popover */}
                <button
                  type="button"
                  onClick={() => { onComplete?.(item.id); handleSave(); }}
                  className="bs-action-btn"
                  style={{
                    background: item.completed ? 'var(--accent-green)' : 'var(--bg-button)',
                    color: item.completed ? 'white' : 'var(--text-secondary)',
                  }}
                >
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <polyline points="20 6 9 17 4 12"></polyline>
                  </svg>
                  Hecho
                </button>
              </div>
            )}
            {/* Delete, Duplicate and Cancel buttons */}
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center', justifyContent: 'space-between', marginTop: 'auto' }}>
              <div style={{ display: 'flex', gap: '8px' }}>
                {isEditing && <button type="button" onClick={() => { onDelete(item.id); onClose(); }} className="btn-icon-danger" style={{ padding: '10px 12px' }}><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg></button>}
                {isEditing && onDuplicate && <button type="button" onClick={() => { onDuplicate(item.id); onClose(); }} className="btn" style={{ padding: '10px 12px', background: 'var(--bg-button)' }}><svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/></svg></button>}
              </div>
              <button type="button" onClick={handleRequestClose} className="btn" style={{ fontSize: '0.75rem', padding: '8px 16px' }}>Cancelar</button>
            </div>
          </div>
          {showDiscardDialog && <DiscardConfirmDialog onDiscard={() => { if (isNewUntitledItem) onDelete(item.id); lastPopoverCloseTime = Date.now(); onClose(); }} onContinue={() => setShowDiscardDialog(false)} />}
        </>
      );
    };

    // Mobile Day Column Component for scroll-snap
    const MobileDayColumn = ({ day, items, categories, dayEnergy, onComplete, onEdit, onSetEnergy, onDrop, onAdd, onDelete, justDroppedItemId, onGoToToday, onOpenCalendar, monthName, draggingItemType, draggingRecurringRange }) => {
      const isToday = formatDate(day.date) === formatDate(REAL_TODAY);
      const isPast = day.date < REAL_TODAY;
      const dateStr = formatDate(day.date);

      // Get all items for this day (both pending and completed)
      // NEW ZONE LOGIC: recurring zone first, then normal zone; completed items stay in place
      const dayItems = items.filter(i =>
        (i.scheduledDate === dateStr && !i.completed) ||
        (i.completedDate === dateStr && i.completed)
      ).sort((a, b) => {
        // Zone separation: recurring items first, then normal items
        if (!!a.repeat !== !!b.repeat) return a.repeat ? -1 : 1;
        // Within same zone, sort by sortOrder (completed items stay in place)
        return (a.sortOrder || 0) - (b.sortOrder || 0);
      });

      // Separate zones for drag logic (same as desktop)
      const recurringZone = dayItems.filter(i => i.repeat);
      const normalZone = dayItems.filter(i => !i.repeat);

      const [dropIndex, setDropIndex] = useState(-1);
      const [isScrolled, setIsScrolled] = useState(false);
      const columnRef = useRef(null);
      const scrollContainerRef = useRef(null);

      const hasItemData = (e) => Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata');

      const handleItemDragOver = (e, index) => {
        if (hasItemData(e)) {
          e.preventDefault();
          e.stopPropagation();
          const rect = e.currentTarget.getBoundingClientRect();
          const y = e.clientY - rect.top;
          const isTopHalf = y < rect.height / 2;
          let targetIndex = isTopHalf ? index : index + 1;

          // If dragging a recurring item over normal zone, clamp to end of recurring zone
          if (draggingItemType === 'recurring' && targetIndex > recurringZone.length) {
            targetIndex = recurringZone.length;
          }
          // If dragging a normal item over recurring zone, clamp to start of normal zone
          if ((draggingItemType === 'normal' || draggingItemType === 'important') && targetIndex < recurringZone.length) {
            targetIndex = recurringZone.length;
          }

          setDropIndex(targetIndex);
        }
      };

      const handleColumnDragOver = (e) => {
        if (hasItemData(e)) {
          e.preventDefault();
          if (!e.target.closest('[data-mobile-item]')) {
            // If dragging a recurring item, drop at end of recurring zone, not end of all items
            if (draggingItemType === 'recurring') {
              setDropIndex(recurringZone.length);
            } else {
              setDropIndex(dayItems.length);
            }
          }
        }
      };

      const handleDragLeave = (e) => {
        if (columnRef.current && !columnRef.current.contains(e.relatedTarget)) {
          setDropIndex(-1);
        }
      };

      const handleDrop = (e) => {
        e.preventDefault();
        const currentDropIndex = dropIndex;
        setDropIndex(-1);
        const data = e.dataTransfer.getData('itemData');
        if (data) {
          onDrop(JSON.parse(data), dateStr, 'todo', currentDropIndex, { x: e.clientX, y: e.clientY });
        }
      };

      // Header text color based on day type
      const getHeaderColor = () => {
        if (isToday) return 'var(--accent-blue)';
        if (isPast) return 'var(--text-past)';
        return 'var(--text-primary)';
      };

      // Handle scroll to show/hide header border
      const handleScroll = (e) => {
        setIsScrolled(e.target.scrollTop > 0);
      };

      // Mute column if outside valid range for recurring item drag
      const isMutedForRecurring = (() => {
        if (draggingItemType !== 'recurring') return false;
        if (isPast) return true; // Always mute past days for recurring
        if (draggingRecurringRange) {
          const { minDate, maxDate } = draggingRecurringRange;
          if (minDate && dateStr < minDate) return true;
          if (maxDate && dateStr > maxDate) return true;
        }
        return false;
      })();

      return (
        <div
          ref={columnRef}
          className="mobile-day-column"
          onDragOver={isMutedForRecurring ? undefined : handleColumnDragOver}
          onDragLeave={handleDragLeave}
          onDrop={isMutedForRecurring ? undefined : handleDrop}
          style={{ display: 'flex', flexDirection: 'column', background: 'var(--bg-primary)', opacity: isMutedForRecurring ? 0.3 : 1, pointerEvents: isMutedForRecurring ? 'none' : 'auto' }}
        >
          {/* Day header - desktop style with 150% size */}
          <div style={{
            padding: '10px 20px 10px',
            touchAction: 'none',
            borderBottom: isScrolled ? '1px solid var(--border-color)' : '1px solid transparent',
            transition: 'border-color 0.15s',
          }}>
            <div style={{
              fontSize: '1.375rem',
              color: getHeaderColor(),
            }}>
              <span style={{ fontWeight: '700' }}>{formatDayNumber(day.date)}</span>
              <span style={{ fontWeight: '400' }}> {formatDayNameFull(day.date)}</span>
            </div>
          </div>

          {/* Items list - 150% scale with more padding */}
          <div ref={scrollContainerRef} onScroll={handleScroll} style={{ flex: 1, overflow: 'auto', padding: '0 20px 16px' }} className="hide-scrollbar">
            {/* Drop indicator at top */}
            <div className={`drop-indicator ${dropIndex === 0 ? 'visible' : ''}`} />
            {dayItems.map((item, index) => (
              <div
                key={item.id}
                data-mobile-item="true"
                onDragOver={(e) => handleItemDragOver(e, index)}
                style={{ marginBottom: '0' }}
              >
                <ItemCard item={item} categories={categories} onComplete={onComplete} onEdit={onEdit} isToday={isToday} isPast={isPast} justDroppedItemId={justDroppedItemId} />
                <div className={`drop-indicator ${dropIndex === index + 1 ? 'visible' : ''}`} />
              </div>
            ))}
            {/* Empty space for adding items */}
            <div style={{ minHeight: '100px', flex: 1 }} />
          </div>
        </div>
      );
    };

    // ============ MAIN APP ============
    // Helper to load state from localStorage
    const loadFromStorage = (key, defaultValue) => {
      try {
        const saved = localStorage.getItem(key);
        return saved ? JSON.parse(saved) : defaultValue;
      } catch (e) {
        return defaultValue;
      }
    };

    const App = () => {
      const theme = 'dark'; // Dark mode only
      const [categories, setCategories] = useState(initialCategories);
      const [items, setItems] = useState(initialItems);
      const [dayEnergy, setDayEnergy] = useState(initialDayEnergy);

      // Load expanded state from localStorage, fallback to all expanded
      const defaultExpanded = { temp: true, ai: true, work: true, health: true, social: true, music: true, entertainment: true, home: true, fitness: true };
      const [expanded, setExpanded] = useState(() => loadFromStorage('tudux_expanded', defaultExpanded));

      // Groups expanded state per category: { categoryId: { backlog: bool, scheduled: bool, done: bool } }
      const defaultGroupsExp = {};
      initialCategories.forEach(c => { defaultGroupsExp[c.id] = { backlog: true, scheduled: true, done: true }; });
      const [categoryGroupsExp, setCategoryGroupsExp] = useState(() => loadFromStorage('tudux_groups', defaultGroupsExp));

      const [groupsExpandedState, setGroupsExpandedState] = useState(null); // null, 'expanded', 'collapsed'
      const [calendarRect, setCalendarRect] = useState(null);
      const [editPopover, setEditPopover] = useState(null);
      const [newCatRect, setNewCatRect] = useState(null);
      const [dragOverCat, setDragOverCat] = useState(null);
      const [viewBase, setViewBase] = useState(REAL_TODAY);
      const [recurringEditPopover, setRecurringEditPopover] = useState(null);
      const [recurringDeletePopover, setRecurringDeletePopover] = useState(null); // For recurring delete confirmation
      const [recurringSavePopover, setRecurringSavePopover] = useState(null); // For edit property confirmation
      const [pendingRecurringDrop, setPendingRecurringDrop] = useState(null); // Temporary visual position during recurring move
      const [removeRecurrenceAlert, setRemoveRecurrenceAlert] = useState(null); // Alert when moving recurring to normal zone
      const [toast, setToast] = useState(null);
      const [categoriesModalOpen, setCategoriesModalOpen] = useState(false);
      const [justDroppedItemId, setJustDroppedItemId] = useState(null); // For drop feedback animation
      const [justShimmeredItemId, setJustShimmeredItemId] = useState(null); // For reverse shimmer animation on scheduled item click
      const [draggingUnscheduledItem, setDraggingUnscheduledItem] = useState(false); // Track when dragging unscheduled item
      const [draggingItemType, setDraggingItemType] = useState(null); // 'recurring' | 'important' | 'normal' | null - for zone muting
      const [draggingRecurringRange, setDraggingRecurringRange] = useState(null); // { minDate, maxDate } - valid move range for dragged recurring item

      // Mobile states
      const [isMobile, setIsMobile] = useState(typeof window !== 'undefined' && window.innerWidth <= 600);
      const [mobileViewMode, setMobileViewMode] = useState('calendar'); // 'calendar' | 'categories'
      const [currentMobileDay, setCurrentMobileDay] = useState(REAL_TODAY);
      const [bottomSheetItem, setBottomSheetItem] = useState(null);
      const [bottomSheetClosing, setBottomSheetClosing] = useState(false);

      // Hide scrollbar when bottom sheet is open (but not when keyboard is shown)
      useEffect(() => {
        if (bottomSheetItem) {
          document.body.classList.add('popover-open');
        } else {
          document.body.classList.remove('popover-open');
        }
        return () => document.body.classList.remove('popover-open');
      }, [bottomSheetItem]);

      // Mobile scroll ref
      const mobileScrollRef = useRef(null);
      const isScrollingRef = useRef(false);

      const scrollRef = useRef(null);
      const days = getDaysArray(viewBase, isMobile ? MOBILE_PAST_DAYS : 1);

      const minDate = useMemo(() => {
        const d = new Date(REAL_TODAY);
        d.setMonth(d.getMonth() - 2);
        return d;
      }, []);

      const maxDate = useMemo(() => {
        const d = new Date(REAL_TODAY);
        d.setMonth(d.getMonth() + 2);
        return d;
      }, []);

      // Persist expanded states to localStorage
      useEffect(() => {
        try {
          localStorage.setItem('tudux_expanded', JSON.stringify(expanded));
        } catch (e) {}
      }, [expanded]);

      useEffect(() => {
        try {
          localStorage.setItem('tudux_groups', JSON.stringify(categoryGroupsExp));
        } catch (e) {}
      }, [categoryGroupsExp]);

      // Track when dragging an unscheduled item (for disabling Agendado section)
      useEffect(() => {
        const handleDragStart = (e) => {
          const data = e.dataTransfer?.getData('itemData');
          // dataTransfer.getData doesn't work during dragstart, so we check via a custom attribute
          // or by checking the target element
          if (e.target.hasAttribute('data-item-id')) {
            const itemId = e.target.getAttribute('data-item-id');
            const numId = typeof itemId === 'string' ? parseInt(itemId.split('-')[0]) : parseInt(itemId);
            const item = items.find(i => i.id === numId);
            if (item && !item.scheduledDate && !item.repeat) {
              setDraggingUnscheduledItem(true);
            }
            // Set dragging item type for zone muting
            if (item) {
              const itemType = item.repeat ? 'recurring' : (item.isImportant ? 'important' : 'normal');
              setDraggingItemType(itemType);

              // Compute valid range for recurring items
              if (item.repeat) {
                // Extract visual date from item ID (format: baseId-YYYY-MM-DD)
                let visualDate = null;
                if (typeof itemId === 'string' && itemId.includes('-')) {
                  const parts = itemId.split('-');
                  if (parts.length >= 4) {
                    visualDate = `${parts[1]}-${parts[2]}-${parts[3]}`;
                  }
                }
                if (!visualDate) visualDate = item.scheduledDate || item.createdAt;
                if (visualDate) {
                  const range = getValidMoveRange(item, visualDate);
                  setDraggingRecurringRange(range);
                }
              }
            }
          }
        };
        const handleDragEnd = () => {
          setDraggingUnscheduledItem(false);
          setDraggingItemType(null); // Reset mute state
          setDraggingRecurringRange(null);
        };
        // Allow drop on document body so 'drop' event fires even on muted areas
        // (without this, dragend fires only after browser snap-back animation ~1s delay)
        const handleDocumentDragOver = (e) => {
          // Only preventDefault if we're actively dragging an item (to allow drop event to fire)
          if (e.dataTransfer && Array.from(e.dataTransfer.types).some(t => t.toLowerCase() === 'itemdata')) {
            e.preventDefault();
          }
        };
        const handleDocumentDrop = (e) => {
          // Reset mute state immediately on any drop (including on muted areas)
          setDraggingUnscheduledItem(false);
          setDraggingItemType(null);
          setDraggingRecurringRange(null);
        };
        document.addEventListener('dragstart', handleDragStart);
        document.addEventListener('dragend', handleDragEnd);
        document.addEventListener('dragover', handleDocumentDragOver);
        document.addEventListener('drop', handleDocumentDrop);
        return () => {
          document.removeEventListener('dragstart', handleDragStart);
          document.removeEventListener('dragend', handleDragEnd);
          document.removeEventListener('dragover', handleDocumentDragOver);
          document.removeEventListener('drop', handleDocumentDrop);
        };
      }, [items]);

      const allItemsWithRecurring = useMemo(() => {
        let result = generateRecurringInstances(items, minDate, maxDate);

        // If there's a pending recurring drop, add the pending item and hide the original instance
        if (pendingRecurringDrop) {
          const originalId = pendingRecurringDrop.id.replace('-pending', '');
          const originalVisualDate = pendingRecurringDrop._originalVisualDate;
          const originalSlot = pendingRecurringDrop._originalSlot;
          const targetDate = pendingRecurringDrop.scheduledDate;
          const targetSlot = pendingRecurringDrop.scheduledSlot;
          const dropIndex = pendingRecurringDrop._dropIndex;

          // Hide the original instance at its original position
          result = result.filter(item => {
            // Check if this is the original instance we're moving
            const itemBaseId = typeof item.id === 'string' ? item.id.split('-')[0] : String(item.id);
            const isOriginalInstance = itemBaseId === originalId &&
              item.scheduledDate === originalVisualDate &&
              item.scheduledSlot === originalSlot;
            return !isOriginalInstance;
          });

          // Get items in target slot (excluding the original we're moving)
          // For 'done' slot, filter by completed items with completedDate
          const targetSlotItems = result.filter(i => {
            if (targetSlot === 'done') {
              return i.completedDate === targetDate && i.completed;
            }
            return i.scheduledDate === targetDate &&
              i.scheduledSlot === targetSlot &&
              !i.completed;
          }).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

          // Insert pending item at correct position
          const safeDropIndex = Math.max(0, Math.min(dropIndex || 0, targetSlotItems.length));
          const newOrder = [...targetSlotItems];
          newOrder.splice(safeDropIndex, 0, pendingRecurringDrop);

          // Reassign consecutive sortOrders to all items in target slot
          const newSortOrders = {};
          newOrder.forEach((item, idx) => {
            newSortOrders[item.id] = idx;
          });

          // Update sortOrders in result
          result = result.map(item => {
            if (newSortOrders[item.id] !== undefined) {
              return { ...item, sortOrder: newSortOrders[item.id] };
            }
            return item;
          });

          // Add the pending item with correct sortOrder
          result.push({ ...pendingRecurringDrop, sortOrder: newSortOrders[pendingRecurringDrop.id] });
        }

        return result;
      }, [items, minDate, maxDate, pendingRecurringDrop]);

      // Backlog: items without scheduled date, not completed, not archived, not recurring
      const backlogItems = useMemo(() => {
        return items.filter(i => !i.scheduledDate && !i.completed && !i.isArchived && !i.repeat);
      }, [items]);

      const firstVisible = days[1].date;
      const lastVisible = days[days.length - 1].date;
      const rangeText = `${formatDayNumber(firstVisible)}-${formatDayNumber(lastVisible)} ${getShortMonthName(lastVisible)}`;

      useEffect(() => { document.documentElement.setAttribute('data-theme', theme); }, [theme]);

      // Detect mobile/desktop on resize
      useEffect(() => {
        const handleResize = () => setIsMobile(window.innerWidth <= 600);
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      // Auto-scroll during drag near edges
      const handleCalendarDragOver = useCallback((e) => {
        const el = scrollRef.current;
        if (!el) return;
        const rect = el.getBoundingClientRect();
        const x = e.clientX;
        const edgeSize = 80; // px from edge to trigger scroll
        const scrollSpeed = 16; // px per frame (doubled from typical 8)

        if (x < rect.left + edgeSize) {
          el.scrollLeft -= scrollSpeed;
        } else if (x > rect.right - edgeSize) {
          el.scrollLeft += scrollSpeed;
        }
      }, []);

      const handleComplete = (id) => {
        // Check if this is a recurring instance with date in ID
        // Format can be: baseId-YYYY-MM-DD or baseId-YYYY-MM-DD-moved
        const isRecurringInstanceWithDate = typeof id === 'string' && /^\d+-\d{4}-\d{2}-\d{2}/.test(id);
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : id;

        if (isRecurringInstanceWithDate) {
          // Extract the date part (YYYY-MM-DD), handling both regular and moved instances
          const parts = id.split('-');
          const instanceDate = `${parts[1]}-${parts[2]}-${parts[3]}`; // Always YYYY-MM-DD (original date for moved items)
          const isMoved = id.endsWith('-moved');

          setItems(p => p.map(i => {
            if (i.id !== numId) return i;
            const newExceptions = { ...(i.exceptions || {}) };
            const currentException = newExceptions[instanceDate] || {};

            // Determine the actual display date (for completedDate)
            // For moved instances, use movedTo.date; otherwise use instanceDate
            const displayDate = currentException.movedTo?.date || instanceDate;

            // Toggle completed state for this instance
            if (currentException.completed) {
              delete newExceptions[instanceDate].completed;
              delete newExceptions[instanceDate].completedDate;
              // Clean up empty exception only if no other properties
              if (Object.keys(newExceptions[instanceDate]).length === 0) {
                delete newExceptions[instanceDate];
              }
            } else {
              newExceptions[instanceDate] = {
                ...currentException,
                completed: true,
                completedDate: displayDate
              };
            }
            return { ...i, exceptions: Object.keys(newExceptions).length > 0 ? newExceptions : undefined };
          }));
        } else {
          // For non-recurring items OR recurring items from sidebar (no date in ID)
          setItems(p => p.map(i => {
            if (i.id !== numId) return i;

            // If it's a recurring item without date in ID (from sidebar), create exception for today
            if (i.repeat) {
              const todayStr = formatDate(REAL_TODAY);
              const newExceptions = { ...(i.exceptions || {}) };
              const currentException = newExceptions[todayStr] || {};
              if (currentException.completed) {
                delete newExceptions[todayStr].completed;
                delete newExceptions[todayStr].completedDate;
                if (Object.keys(newExceptions[todayStr]).length === 0) {
                  delete newExceptions[todayStr];
                }
              } else {
                newExceptions[todayStr] = {
                  ...currentException,
                  completed: true,
                  completedDate: todayStr
                };
              }
              return { ...i, exceptions: Object.keys(newExceptions).length > 0 ? newExceptions : undefined };
            }

            // For regular non-recurring items
            // Category items (no scheduledDate) stay in place when completed
            const completedDate = !i.completed
              ? (i.scheduledDate ? i.scheduledDate : null) // No date for category items
              : null;
            // Items stay in place when toggling completed status - keep same sortOrder
            // Preserve isImportant status when toggling completed
            return { ...i, completed: !i.completed, completedDate };
          }));
        }
      };

      const handleSave = (data, forceApplyAll = false) => {
        const numId = data.id && typeof data.id === 'string' ? parseInt(data.id.split('-')[0]) : data.id;
        // Remove internal markers if present when updating existing items
        const { _isNewItem, _addAtEnd, ...cleanData } = data;
        if (numId) {
          const existingItem = items.find(i => i.id === numId);
          const wasScheduled = existingItem && (existingItem.scheduledDate || existingItem.repeat);
          // Item is now backlog if it has no date and no repeat (completed status doesn't matter for the move)
          const isNowBacklog = !cleanData.scheduledDate && !cleanData.repeat;
          const isRecurring = existingItem?.repeat;

          // Check if relevant properties changed for recurring items
          const propsChanged = isRecurring && (
            existingItem.title !== cleanData.title ||
            existingItem.description !== cleanData.description ||
            existingItem.effort !== cleanData.effort
          );

          // Get the visual date from desktop or mobile popover
          const currentVisualDate = editPopover?.visualDate || bottomSheetItem?.visualDate || null;
          const currentEditItem = editPopover?.item || bottomSheetItem?.item || null;

          // Don't allow modifying recurring items on past days
          const visualDateObj = currentVisualDate ? new Date(currentVisualDate + 'T00:00:00') : null;
          const isPastDay = visualDateObj && visualDateObj < REAL_TODAY;
          if (isRecurring && propsChanged && isPastDay) {
            // Silently ignore changes to recurring items on past days
            setEditPopover(null);
            return;
          }

          // Check if recurring item date changed (Outlook-style: show move options)
          const dateChanged = isRecurring && currentVisualDate && cleanData.scheduledDate && cleanData.scheduledDate !== currentVisualDate;
          if (dateChanged) {
            const targetDate = cleanData.scheduledDate;
            const visualDate = currentVisualDate;

            // Validate range restriction (Outlook model: can't skip over adjacent instances)
            // Calendar disables invalid dates, but validate as safety net
            const { minDate, maxDate } = getValidMoveRange(existingItem, visualDate);
            if ((minDate && targetDate < minDate) || (maxDate && targetDate > maxDate)) {
              return; // Silently ignore - calendar should have prevented this
            }

            // Get the exception date for this instance
            const editItemId = currentEditItem?.id;
            let exceptionDate = visualDate;
            if (editItemId && typeof editItemId === 'string') {
              if (currentEditItem?.originalScheduledDate) {
                exceptionDate = currentEditItem.originalScheduledDate;
              } else if (editItemId.includes('-')) {
                const parts = editItemId.split('-');
                if (parts.length >= 4) {
                  exceptionDate = `${parts[1]}-${parts[2]}-${parts[3]}`;
                }
              }
            }

            // Also apply any property changes alongside the date change
            if (propsChanged) {
              // Apply property changes to all instances first
              setItems(p => p.map(i => i.id === numId ? {
                ...i,
                title: cleanData.title,
                description: cleanData.description,
                effort: cleanData.effort,
              } : i));
            }

            // Show recurring move popover for date change
            const rect = editPopover?.rect || { top: window.innerHeight / 2, left: window.innerWidth / 2, bottom: window.innerHeight / 2, right: window.innerWidth / 2 };
            setRecurringEditPopover({
              item: existingItem,
              exceptionDate,
              visualDate,
              originalSlot: existingItem.scheduledSlot || 'todo',
              targetDate,
              targetSlot: cleanData.scheduledSlot || existingItem.scheduledSlot || 'todo',
              dropIndex: 0,
              action: 'move',
              rect,
            });
            setEditPopover(null);
            return;
          }

          // If recurring item with property changes, show confirmation popover
          if (propsChanged && !forceApplyAll && editPopover?.visualDate) {
            setRecurringSavePopover({
              existingItem,
              cleanData,
              numId,
              visualDate: editPopover.visualDate,
              rect: editPopover.rect
            });
            return; // Don't save yet, wait for user choice
          }

          if (wasScheduled && isNowBacklog) {
            // Item moved to backlog - put it first in its category with lowest sortOrder
            setItems(p => {
              // Get all backlog items in the same category to find the min sortOrder
              const categoryBacklogItems = p.filter(i =>
                i.id !== numId &&
                i.category === cleanData.category &&
                !i.scheduledDate &&
                !i.repeat
              );
              const minSortOrder = categoryBacklogItems.length > 0
                ? Math.min(...categoryBacklogItems.map(i => i.sortOrder || 0))
                : 0;
              return [
                { ...existingItem, ...cleanData, id: numId, _isNewItem: undefined, _addAtEnd: undefined, sortOrder: minSortOrder - 1 },
                ...p.filter(i => i.id !== numId)
              ];
            });
          } else {
            setItems(p => p.map(i => i.id === numId ? { ...i, ...cleanData, id: numId, _isNewItem: undefined, _addAtEnd: undefined } : i));
          }
        } else {
          // For new items, keep _isNewItem marker if present (for auto-opening popover)
          // Adjust scheduled date if creating weekdays repeat on invalid day
          let adjustedScheduledDate = cleanData.scheduledDate;
          if (cleanData.repeat?.type === 'weekdays' && cleanData.scheduledDate) {
            const nextValidDate = findNextValidDate(cleanData.scheduledDate, cleanData.repeat);
            if (nextValidDate !== cleanData.scheduledDate) {
              adjustedScheduledDate = nextValidDate;
              setToast({ message: `Programado para ${formatDateLabel(nextValidDate)} (primer día del patrón)` });
            }
          }
          const newItem = {
            id: Date.now(),
            ...cleanData,
            scheduledDate: adjustedScheduledDate,
            completed: cleanData.completed || false,
            completedDate: cleanData.completedDate || null,
            createdAt: formatDate(REAL_TODAY),
            isArchived: false,
            _isNewItem: data._isNewItem || false,
            _addAtEnd: data._addAtEnd || false,
          };
          setItems(p => [...p, newItem]);
        }
        setEditPopover(null);
      };

      // Handle recurring save choice: "Solo este evento"
      const handleRecurringSaveThis = () => {
        if (!recurringSavePopover) return;
        const { existingItem, cleanData, numId, visualDate } = recurringSavePopover;

        // Create exception with property overrides for this instance
        setItems(p => p.map(i => {
          if (i.id !== numId) return i;
          const newExceptions = { ...(i.exceptions || {}) };
          const existingException = newExceptions[visualDate] || {};
          newExceptions[visualDate] = {
            ...existingException,
            title: cleanData.title,
            description: cleanData.description,
            effort: cleanData.effort,
          };
          return { ...i, exceptions: newExceptions };
        }));

        setRecurringSavePopover(null);
        setEditPopover(null);
      };

      // Handle recurring save choice: "Este y los siguientes"
      const handleRecurringSaveFollowing = () => {
        if (!recurringSavePopover) return;
        const { existingItem, cleanData, numId, visualDate } = recurringSavePopover;

        setItems(p => {
          // End the original series the day before visualDate
          const endDateObj = new Date(visualDate + 'T00:00:00');
          endDateObj.setDate(endDateObj.getDate() - 1);

          const updated = p.map(i => {
            if (i.id !== numId) return i;
            return {
              ...i,
              repeat: { ...i.repeat, endDate: formatDate(endDateObj) }
            };
          });

          // Create new series with updated properties
          const newRepeat = { ...existingItem.repeat };
          delete newRepeat.endDate;
          newRepeat.startDate = visualDate;

          const newItem = {
            id: Date.now(),
            title: cleanData.title,
            description: cleanData.description,
            category: cleanData.category,
            effort: cleanData.effort,
            scheduledSlot: cleanData.scheduledSlot || existingItem.scheduledSlot,
            sortOrder: existingItem.sortOrder,
            completed: false,
            completedDate: null,
            createdAt: existingItem.createdAt,
            isArchived: false,
            repeat: newRepeat,
          };

          return [...updated, newItem];
        });

        setRecurringSavePopover(null);
        setEditPopover(null);
      };

      const handleDelete = (id) => {
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : id;
        const item = items.find(i => i.id === numId);

        // If item is recurring, show delete options popover
        if (item?.repeat) {
          const visualDate = editPopover?.visualDate || bottomSheetItem?.visualDate;
          if (visualDate) {
            // Determine exceptionDate: check if this instance was moved (movedTo)
            let exceptionDate = visualDate;
            if (item.exceptions) {
              for (const [origDate, exc] of Object.entries(item.exceptions)) {
                if (exc.movedTo && exc.movedTo.date === visualDate) {
                  exceptionDate = origDate;
                  break;
                }
              }
            }
            const rect = editPopover?.rect || { top: window.innerHeight / 2, left: window.innerWidth / 2, width: 0, height: 0 };
            setRecurringDeletePopover({ item, exceptionDate, visualDate, rect });
            return;
          }
        }

        // Non-recurring: delete normally
        const deletedIndex = items.findIndex(i => i.id === numId);
        const deletedItem = deletedIndex >= 0 ? items[deletedIndex] : null;
        setItems(p => p.filter(i => i.id !== numId));

        // Show undo toast only if item has a title (not empty/untitled items)
        if (deletedItem && deletedItem.title && deletedItem.title.trim() !== '') {
          setToast({
            message: `"${deletedItem.title}" eliminado`,
            item: deletedItem,
            index: deletedIndex,
          });
        }
      };

      const handleUndoDelete = () => {
        if (toast?.item) {
          const idx = toast.index ?? -1;
          setItems(p => {
            const newItems = [...p];
            const insertAt = Math.min(idx, newItems.length);
            if (insertAt >= 0) {
              newItems.splice(insertAt, 0, toast.item);
            } else {
              newItems.push(toast.item);
            }
            return newItems;
          });
          // Trigger drop shimmer on the restored item
          setJustDroppedItemId(toast.item.id);
          setTimeout(() => setJustDroppedItemId(null), 300);
        } else if (toast?.deletedItems) {
          // Undo bulk delete (e.g. "borrar hechos") - restore all items at their original positions
          setItems(p => {
            const newItems = [...p];
            // Sort by index ascending so earlier insertions don't shift later ones
            const sorted = [...toast.deletedItems].sort((a, b) => a.index - b.index);
            sorted.forEach(({ item, index }) => {
              const insertAt = Math.min(index, newItems.length);
              newItems.splice(insertAt, 0, item);
            });
            return newItems;
          });
        } else if (toast?.hiddenIds) {
          setItems(p => p.map(i => toast.hiddenIds.includes(i.id) ? { ...i, hiddenFromSidebar: false } : i));
        } else if (toast?.recurringDeleteUndo) {
          // Undo recurring delete: restore the item to its previous state
          const { itemId, previousItem } = toast.recurringDeleteUndo;
          setItems(p => p.map(i => i.id === itemId ? previousItem : i));
        }
        setToast(null);
      };

      const handleDuplicate = (id) => {
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : id;
        const originalItem = items.find(i => i.id === numId);
        if (!originalItem) return;

        const isRecurring = !!originalItem.repeat;
        const newId = Date.now();

        // For recurring items: duplicate as a normal (non-recurring) item at the top of the day's list
        // For normal items: duplicate right below the original
        const visualDate = editPopover?.visualDate || bottomSheetItem?.visualDate || originalItem.scheduledDate;
        const duplicatedItem = {
          ...originalItem,
          id: newId,
          completed: false,
          completedDate: null,
          createdAt: formatDate(REAL_TODAY),
          repeat: null, // Always create as non-recurring
          exceptions: undefined,
          dateOverrides: undefined,
          scheduledDate: isRecurring ? (visualDate || originalItem.scheduledDate) : originalItem.scheduledDate,
          scheduledSlot: originalItem.scheduledSlot || 'todo',
          sortOrder: isRecurring ? -1 : (originalItem.sortOrder || 0) + 0.5,
        };

        if (isRecurring) {
          // For recurring: add at top of normal zone (low sortOrder)
          setItems(p => [...p, duplicatedItem]);
        } else {
          // For normal: insert right after the original item
          setItems(p => {
            const idx = p.findIndex(i => i.id === numId);
            const newItems = [...p];
            newItems.splice(idx + 1, 0, duplicatedItem);
            return newItems;
          });
        }

        // Trigger drop shimmer on the new item
        setJustDroppedItemId(newId);
        setTimeout(() => setJustDroppedItemId(null), 300);

        // Close popovers
        setEditPopover(null);
      };

      // Keyboard shortcut: Cmd+Z / Ctrl+Z for undo
      useEffect(() => {
        const handleKeyDown = (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
            if (toast?.item || toast?.hiddenIds) {
              e.preventDefault();
              handleUndoDelete();
            }
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [toast]);

      // Toggle important status - marks item as important (red, moves to top)
      const handleToggleImportant = (id) => {
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : id;
        setItems(p => {
          const item = p.find(i => i.id === numId);
          if (!item) return p;
          // Recurring items cannot be marked as important
          if (item.repeat) return p;
          // Simply toggle isImportant - item stays in place (no reordering)
          return p.map(i => i.id === numId ? { ...i, isImportant: !i.isImportant } : i);
        });
      };

      const handleDrop = (data, date, slot, dropIndex, coords) => {
        console.log('handleDrop called', { data, date, slot, dropIndex, coords });
        const { id, isRecurring, exceptionDate, visualDate, originalSlot, title } = data;
        // For backward compatibility, use exceptionDate if visualDate not present
        const effectiveVisualDate = visualDate || exceptionDate;
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : parseInt(id);
        console.log('Parsed:', { numId, isRecurring, exceptionDate, visualDate, effectiveVisualDate });

        // Find the original item to get full data for recurring edit
        const originalItem = items.find(i => i.id === numId);

        if (isRecurring && !originalItem) {
          console.error('Could not find original item for recurring edit', numId);
          return;
        }

        if (isRecurring) {
          const sameDay = effectiveVisualDate === date;
          const sameSlot = originalSlot === slot;
          console.log('Recurring item check:', { sameDay, sameSlot, effectiveVisualDate, date, originalSlot, slot });

          // Validate move range (Outlook model: can't skip over other instances)
          if (!sameDay) {
            const { minDate, maxDate } = getValidMoveRange(originalItem, effectiveVisualDate);
            console.log('Valid move range:', { minDate, maxDate, targetDate: date });

            // Check if target date is within valid range - silently ignore if outside range
            if ((minDate && date < minDate) || (maxDate && date > maxDate)) {
              setDraggingItemType(null);
              return;
            }
          }

          if (sameDay && sameSlot) {
            // Solo reordenar dentro del mismo slot
            console.log('Same day, same slot - checking if moving to normal zone');

            // Get all items for this day (excluding the dragged one)
            const dayItemsExcludingDragged = allItemsWithRecurring.filter(i => {
              const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
              if (baseId === numId) return false;
              return (i.scheduledDate === date && !i.completed);
            });

            // Count recurring items among the others (they appear first due to sorting)
            const otherRecurringCount = dayItemsExcludingDragged.filter(i => i.repeat || i.originalId).length;

            // Count non-recurring items
            const normalItemsCount = dayItemsExcludingDragged.filter(i => !i.repeat && !i.originalId).length;

            // If there are normal items and dropIndex is beyond the recurring zone, show alert
            // The recurring zone ends at index = otherRecurringCount + 1 (because the dragged item is also recurring)
            // dropIndex is clamped to recurringZone.length which includes the dragged item
            // So we compare with otherRecurringCount + 1 to account for the dragged item
            if (normalItemsCount > 0 && dropIndex > otherRecurringCount + 1) {
              console.log('Moving recurring to normal zone - showing alert', { dropIndex, otherRecurringCount, normalItemsCount });
              setDraggingItemType(null); // Reset mute state when showing alert
              setRemoveRecurrenceAlert({
                item: originalItem,
                date,
                slot,
                dropIndex,
                coords,
              });
              return;
            }

            // Otherwise just reorder within recurring zone or append after all items
            setDraggingItemType(null); // Reset mute state
            performDrop(numId, date, slot, dropIndex);
            return;
          }

          if (sameDay && !sameSlot) {
            // Cambio de slot en el mismo día - modificar exception pero mantener recurrencia
            console.log('Same day, different slot - modify exception, keep recurrence');
            handleRecurringSameDaySlotChange(originalItem, exceptionDate, date, slot, dropIndex);
            return;
          }

          // Diferente día - mostrar popover de opciones (incluyendo movimientos a/desde done)
          // Set pending drop to show item temporarily in target position
          // Calculate proper sortOrder for the pending item
          const slotItems = allItemsWithRecurring.filter(i => {
            const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
            if (baseId === numId) return false;
            if (slot === 'done') {
              return i.completedDate === date && i.completed;
            }
            return i.scheduledDate === date &&
              i.scheduledSlot === slot &&
              !i.completed;
          }).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

          const safeDropIndex = Math.max(0, Math.min(dropIndex || 0, slotItems.length));

          const pendingItem = {
            ...originalItem,
            id: `${originalItem.id}-pending`,
            scheduledDate: date,
            scheduledSlot: slot,
            sortOrder: 0, // Will be recalculated in allItemsWithRecurring
            _isPending: true,
            _originalVisualDate: effectiveVisualDate,
            _originalSlot: originalSlot,
            _dropIndex: safeDropIndex,
            // If moving to done, mark as completed for correct filtering
            completed: slot === 'done' ? true : false,
            completedDate: slot === 'done' ? date : null,
          };

          setPendingRecurringDrop(pendingItem);
          setDraggingItemType(null); // Reset mute state when showing popover

          console.log('Different day - showing popover');
          setRecurringEditPopover({
            item: originalItem,
            exceptionDate,
            visualDate: effectiveVisualDate,
            originalSlot,
            targetDate: date,
            targetSlot: slot,
            dropIndex,
            action: 'move',
            pendingItemId: pendingItem.id,
            dropCoords: coords,
          });
          return;
        }

        // For non-recurring items, check if moving important/completed item to normal zone
        // Preserve item states - only remove completed if explicitly dropping to non-done slot from done
        const dropOptions = {};

        setDraggingItemType(null); // Reset mute state
        performDrop(numId, date, slot, dropIndex, dropOptions);
      };

      const performDrop = (numId, date, slot, dropIndex, options = {}) => {
        // Options: { removeImportant: bool, removeCompleted: bool }
        const { removeImportant, removeCompleted } = options;

        // Get visual items for this date (includes recurring instances)
        // NEW ZONE LOGIC: recurring zone first, then normal zone; completed items stay in place
        const visualSlotItems = allItemsWithRecurring.filter(i =>
          (i.scheduledDate === date && !i.completed) ||
          (i.completedDate === date && i.completed)
        ).sort((a, b) => {
          // Zone separation: recurring items first, then normal items
          if (!!a.repeat !== !!b.repeat) return a.repeat ? -1 : 1;
          // Within same zone, sort by sortOrder (completed items stay in place)
          return (a.sortOrder || 0) - (b.sortOrder || 0);
        });

        // Find original index of dragged item in visual list (if it's already in this slot)
        const originalIndex = visualSlotItems.findIndex(i => {
          const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
          return baseId === numId;
        });

        // Check if item is coming from outside this slot
        const isFromOutside = originalIndex === -1;

        // Adjust dropIndex if dragging from before the drop position (only if already in this slot)
        let adjustedDropIndex = dropIndex || 0;
        if (!isFromOutside && originalIndex < adjustedDropIndex) {
          adjustedDropIndex = adjustedDropIndex - 1;
        }

        // Remove dragged item from visual list (if it was there)
        const visualWithoutDragged = visualSlotItems.filter(i => {
          const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
          return baseId !== numId;
        });

        // Insert at correct position - use a placeholder for the dropped item
        const safeDropIndex = Math.max(0, Math.min(adjustedDropIndex, visualWithoutDragged.length));
        const newVisualOrder = [...visualWithoutDragged];
        // Insert placeholder for dropped item
        newVisualOrder.splice(safeDropIndex, 0, { id: numId, _isDropped: true });

        // Calculate new sortOrders for all items in this slot
        const newSortOrders = {};
        newVisualOrder.forEach((item, idx) => {
          if (item) {
            const baseId = typeof item.id === 'string' ? parseInt(item.id.split('-')[0]) : item.id;
            newSortOrders[baseId] = { sortOrder: idx, isRecurring: !!item.originalId };
          }
        });

        setItems(p => {
          return p.map(i => {
            const sortInfo = newSortOrders[i.id];

            if (i.id === numId) {
              // This is the dropped item
              if (i.repeat) {
                // Recurring item: store sortOrder in dateOverrides for this date
                const newDateOverrides = { ...(i.dateOverrides || {}), [date]: { sortOrder: sortInfo?.sortOrder ?? 0 } };
                return { ...i, dateOverrides: newDateOverrides };
              } else {
                // Non-recurring item: update directly
                if (slot === 'done') {
                  return { ...i, completed: true, completedDate: date, scheduledDate: date, scheduledSlot: i.scheduledSlot || 'todo', sortOrder: sortInfo?.sortOrder ?? 0 };
                }
                // Preserve important and completed status unless explicitly removing
                const newIsImportant = removeImportant ? false : i.isImportant;
                const newCompleted = removeCompleted ? false : i.completed;
                const newCompletedDate = removeCompleted ? null : i.completedDate;
                return { ...i, scheduledDate: date, scheduledSlot: slot, isArchived: false, completed: newCompleted, completedDate: newCompletedDate, sortOrder: sortInfo?.sortOrder ?? 0, isImportant: newIsImportant };
              }
            }

            // Update other items on the same date
            if (sortInfo !== undefined) {
              if (i.repeat) {
                // Recurring item: update dateOverrides
                const newDateOverrides = { ...(i.dateOverrides || {}), [date]: { sortOrder: sortInfo.sortOrder } };
                return { ...i, dateOverrides: newDateOverrides };
              } else if (i.scheduledDate === date || (i.completedDate === date && i.completed)) {
                // Non-recurring item on same date: update sortOrder
                return { ...i, sortOrder: sortInfo.sortOrder };
              }
            }

            return i;
          });
        });

        // Trigger drop feedback animation
        setJustDroppedItemId(numId);
        setTimeout(() => setJustDroppedItemId(null), 300);
      };

      const handleDropCategory = (data, cat, archived) => {
        const { id } = data;
        const numId = typeof id === 'string' ? parseInt(id.split('-')[0]) : parseInt(id);
        setItems(p => p.map(i => i.id === numId ? { ...i, category: cat, isArchived: archived } : i));
      };

      // Handle dropping item on sidebar groups (anyday, backlog, done)
      const handleSidebarGroupDrop = (itemId, targetGroup, categoryId, dropIndex) => {
        setItems(p => {
          // Get ALL items in target group (including the dropped item) to find original position
          let allTargetItems;
          if (targetGroup === 'backlog') {
            allTargetItems = p.filter(i => i.category === categoryId && (i.isArchived || !i.scheduledDate) && !i.completed && !i.repeat);
          } else if (targetGroup === 'done') {
            allTargetItems = p.filter(i => i.category === categoryId && i.completedDate === formatDate(REAL_TODAY) && i.completed);
          } else {
            allTargetItems = [];
          }
          allTargetItems.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

          // Find original index of dragged item in the visual list
          const originalIndex = allTargetItems.findIndex(i => i.id === itemId);

          // Get items without the dragged one
          const targetItems = allTargetItems.filter(i => i.id !== itemId);

          // Adjust dropIndex: if dragging from before the drop position, subtract 1
          let adjustedDropIndex = dropIndex || 0;
          if (originalIndex !== -1 && originalIndex < adjustedDropIndex) {
            adjustedDropIndex = adjustedDropIndex - 1;
          }

          // Insert dropped item at the correct position and reassign all sortOrders
          const droppedItem = p.find(i => i.id === itemId);
          const safeDropIndex = Math.max(0, Math.min(adjustedDropIndex, targetItems.length));
          const newOrder = [...targetItems];
          newOrder.splice(safeDropIndex, 0, droppedItem);

          // Create a map of new sortOrders for all items in this group
          const newSortOrders = {};
          newOrder.forEach((item, idx) => {
            if (item) newSortOrders[item.id] = idx;
          });

          return p.map(i => {
            // Update sortOrder for all items in this group
            if (newSortOrders[i.id] !== undefined && i.id !== itemId) {
              return { ...i, sortOrder: newSortOrders[i.id] };
            }
            if (i.id !== itemId) return i;

            // Update the dropped item
            const baseUpdate = { category: categoryId, sortOrder: newSortOrders[itemId] };
            switch (targetGroup) {
              case 'backlog':
                return { ...i, ...baseUpdate, scheduledDate: null, scheduledSlot: null, isArchived: false, completed: false, completedDate: null, repeat: null, exceptions: null };
              case 'done':
                return { ...i, ...baseUpdate, completed: true, completedDate: formatDate(REAL_TODAY), isArchived: false };
              default:
                return i;
            }
          });
        });

        // Trigger drop feedback animation
        setJustDroppedItemId(itemId);
        setTimeout(() => setJustDroppedItemId(null), 300);
      };

      const handleEditCategory = (u) => {
        if (categories.find(c => c.id === u.id)) {
          setCategories(p => p.map(c => c.id === u.id ? u : c));
        } else {
          // Add new category after Temp (index 1)
          setCategories(p => [p[0], u, ...p.slice(1)]);
          // Open the new category by default
          setExpanded(p => ({ ...p, [u.id]: true }));
        }
      };

      const handleReorderCategory = (dragId, dropId) => {
        if (dragId === dropId) return;
        // Don't allow reordering if dragging to/from Temp
        const dragCat = categories.find(c => c.id === dragId);
        const dropCat = categories.find(c => c.id === dropId);
        if (dragCat?.isFixed || dropCat?.isFixed) return;

        setCategories(p => {
          const a = [...p];
          const di = a.findIndex(c => c.id === dragId);
          const [item] = a.splice(di, 1);
          const dropIndex = a.findIndex(c => c.id === dropId);
          a.splice(dropIndex, 0, item);
          return a;
        });
      };

      const handleEdit = (item, rect) => {
        const originalId = item.originalId || (typeof item.id === 'string' ? parseInt(item.id.split('-')[0]) : item.id);
        const originalItem = items.find(i => i.id === originalId) || item;
        // For recurring items, pass the visual date so it can be used if repeat is removed
        const visualDate = item.scheduledDate;
        setEditPopover({ item: originalItem, rect, visualDate });
      };

      // Handler principal para acciones de recurrencia
      const handleRecurringAction = (choice, options = {}) => {
        console.log('handleRecurringAction called with choice:', choice, 'options:', options);
        if (!recurringEditPopover) {
          console.log('No recurringEditPopover!');
          return;
        }
        const { item, exceptionDate, visualDate, originalSlot, targetDate, targetSlot, dropIndex } = recurringEditPopover;
        console.log('Popover data:', { itemId: item.id, exceptionDate, visualDate, targetDate, targetSlot });

        // If target is "done", only "solo este evento" makes sense for recurring items
        // (can't have a recurring series in "done" slot)
        if (targetSlot === 'done' && choice !== 'this') {
          handleRecurringMoveThis(item, exceptionDate, originalSlot, targetDate, targetSlot, dropIndex);
          setRecurringEditPopover(null);
          setPendingRecurringDrop(null);
          return;
        }

        switch (choice) {
          case 'this':
            // "Solo este evento" uses exceptionDate (the key in exceptions)
            handleRecurringMoveThis(item, exceptionDate, originalSlot, targetDate, targetSlot, dropIndex);
            break;
          case 'following':
            // "Este y siguientes" uses visualDate (where the item appears)
            // options contains: newRepeatType, newDays (for weekdays), newEvery (for days/weeks)
            handleRecurringMoveFollowing(item, exceptionDate, visualDate, originalSlot, targetDate, targetSlot, dropIndex, options);
            break;
          case 'all':
            // "Todos" uses visualDate for calculating the day offset
            handleRecurringMoveAll(item, visualDate, originalSlot, targetDate, targetSlot, dropIndex);
            break;
        }
        setRecurringEditPopover(null);
        setPendingRecurringDrop(null);
      };

      // Calcular sortOrder para posicionar item en slot destino
      // Retorna: { insertedSortOrder: number, otherSortOrders: { [itemId]: number } }
      const calculateSortOrdersForDrop = (targetDate, targetSlot, dropIndex, excludeItemId) => {
        // Obtener items del slot destino, excluyendo el item que estamos moviendo
        const visualSlotItems = allItemsWithRecurring.filter(i => {
          const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
          return i.scheduledDate === targetDate &&
            i.scheduledSlot === targetSlot &&
            !i.completed &&
            baseId !== excludeItemId;
        }).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

        const safeDropIndex = Math.max(0, Math.min(dropIndex || 0, visualSlotItems.length));

        // Crear nuevo orden con placeholder para el item insertado
        const newOrder = [...visualSlotItems];
        newOrder.splice(safeDropIndex, 0, { _inserted: true });

        // Asignar sortOrders consecutivos
        const otherSortOrders = {};
        let insertedSortOrder = 0;

        newOrder.forEach((item, idx) => {
          if (item._inserted) {
            insertedSortOrder = idx;
          } else {
            const baseId = typeof item.id === 'string' ? parseInt(item.id.split('-')[0]) : item.id;
            otherSortOrders[baseId] = idx;
          }
        });

        return { insertedSortOrder, otherSortOrders };
      };

      // Mismo día, cambio de slot: modificar exception pero mantener recurrencia
      // Si va a done: marcar como completed en exception
      // Si sale de done: quitar completed de exception
      // Si va entre important/todo: marcar movedTo en exception
      const handleRecurringSameDaySlotChange = (item, originalDate, targetDate, targetSlot, dropIndex) => {
        console.log('handleRecurringSameDaySlotChange called', { itemId: item.id, originalDate, targetDate, targetSlot, itemSlot: item.scheduledSlot });

        setItems(p => {
          return p.map(i => {
            if (i.id !== item.id) return i;

            const newExceptions = { ...(i.exceptions || {}) };
            const existingException = newExceptions[originalDate] || {};

            if (targetSlot === 'done') {
              // Moving to done - mark as completed
              newExceptions[originalDate] = {
                ...existingException,
                completed: true,
                completedDate: targetDate,
              };
              // Remove movedTo if it was set
              delete newExceptions[originalDate].movedTo;
              delete newExceptions[originalDate].deleted;
            } else if (targetSlot === i.scheduledSlot && !existingException.movedTo) {
              // Moving back to original slot (e.g., from done back to original important/todo)
              // Just remove completed state, no need to set movedTo
              const cleanException = { ...existingException };
              delete cleanException.completed;
              delete cleanException.completedDate;
              delete cleanException.deleted;
              // If exception is now empty, remove it entirely
              if (Object.keys(cleanException).length === 0) {
                delete newExceptions[originalDate];
              } else {
                newExceptions[originalDate] = cleanException;
              }
            } else {
              // Moving to different slot (important<->todo) - set movedTo
              newExceptions[originalDate] = {
                ...existingException,
                movedTo: { date: targetDate, slot: targetSlot },
              };
              delete newExceptions[originalDate].completed;
              delete newExceptions[originalDate].completedDate;
              delete newExceptions[originalDate].deleted;
            }

            return { ...i, exceptions: Object.keys(newExceptions).length > 0 ? newExceptions : undefined };
          });
        });

        // Trigger drop feedback animation
        setJustDroppedItemId(item.id);
        setTimeout(() => setJustDroppedItemId(null), 300);
      };

      // Solo este evento: crear excepción movedTo (modelo Google Calendar)
      // El item sigue siendo parte de la serie recurrente, solo se mueve esta instancia
      const handleRecurringMoveThis = (item, originalDate, originalSlot, targetDate, targetSlot, dropIndex) => {
        console.log('handleRecurringMoveThis called', { itemId: item.id, originalDate, targetDate, targetSlot, dropIndex });

        // Validate originalDate - must be a valid date string
        if (!originalDate || !/^\d{4}-\d{2}-\d{2}$/.test(originalDate)) {
          console.error('Invalid originalDate:', originalDate);
          setToast({ message: 'Error: fecha original inválida' });
          return;
        }

        const { insertedSortOrder, otherSortOrders } = calculateSortOrdersForDrop(targetDate, targetSlot, dropIndex, item.id);

        setItems(p => {
          return p.map(i => {
            if (i.id === item.id) {
              const newExceptions = { ...(i.exceptions || {}) };
              const existingException = newExceptions[originalDate] || {};

              // Si se mueve a "done", marcar como completed
              if (targetSlot === 'done') {
                newExceptions[originalDate] = {
                  ...existingException,
                  movedTo: { date: targetDate, slot: targetSlot },
                  completed: true,
                  completedDate: targetDate,
                };
              } else {
                // Crear excepción movedTo (el item sigue siendo parte de la serie)
                newExceptions[originalDate] = {
                  ...existingException,
                  movedTo: { date: targetDate, slot: targetSlot },
                };
                // Limpiar completed si existía (ya no está en done)
                delete newExceptions[originalDate].completed;
                delete newExceptions[originalDate].completedDate;
              }
              // Limpiar deleted si existía
              delete newExceptions[originalDate].deleted;

              console.log('Created movedTo exception:', { itemId: i.id, originalDate, movedTo: newExceptions[originalDate].movedTo });
              return { ...i, exceptions: newExceptions };
            }

            // Actualizar sortOrder de otros items en el slot destino
            if (otherSortOrders[i.id] !== undefined) {
              if (i.repeat) {
                const newDateOverrides = { ...(i.dateOverrides || {}), [targetDate]: { sortOrder: otherSortOrders[i.id] } };
                return { ...i, dateOverrides: newDateOverrides };
              } else if (i.scheduledDate === targetDate && i.scheduledSlot === targetSlot) {
                return { ...i, sortOrder: otherSortOrders[i.id] };
              }
            }

            return i;
          });
        });

        // Trigger drop feedback animation
        setJustDroppedItemId(item.id);
        setTimeout(() => setJustDroppedItemId(null), 300);
      };

      // Este y los siguientes: terminar serie original, crear nueva
      // exceptionDate: the key in exceptions (if this instance was moved/completed)
      // visualDate: where the item appears visually (used to determine where to split the series)
      // options: { newRepeatType, newDays (for weekdays), newEvery (for days/weeks) }
      const handleRecurringMoveFollowing = (item, exceptionDate, visualDate, originalSlot, targetDate, targetSlot, dropIndex, options = {}) => {
        const { newRepeatType, newDays, newEvery } = options;
        const { insertedSortOrder, otherSortOrders } = calculateSortOrdersForDrop(targetDate, targetSlot, dropIndex, item.id);

        setItems(p => {
          // Terminar la serie original el día anterior a donde aparece visualmente
          const endDateObj = new Date(visualDate + 'T00:00:00');
          endDateObj.setDate(endDateObj.getDate() - 1);

          const updated = p.map(i => {
            if (i.id === item.id) {
              // Remove any exception for this instance since we're moving it to a new series
              const newExceptions = { ...(i.exceptions || {}) };
              if (exceptionDate && newExceptions[exceptionDate]) {
                delete newExceptions[exceptionDate];
              }

              return {
                ...i,
                repeat: { ...i.repeat, endDate: formatDate(endDateObj) },
                exceptions: Object.keys(newExceptions).length > 0 ? newExceptions : undefined
              };
            }

            // Actualizar sortOrder de otros items en el slot destino
            if (otherSortOrders[i.id] !== undefined) {
              if (i.repeat) {
                const newDateOverrides = { ...(i.dateOverrides || {}), [targetDate]: { sortOrder: otherSortOrders[i.id] } };
                return { ...i, dateOverrides: newDateOverrides };
              } else if (i.scheduledDate === targetDate && i.scheduledSlot === targetSlot) {
                return { ...i, sortOrder: otherSortOrders[i.id] };
              }
            }

            return i;
          });

          // Crear nueva serie que empieza a partir de targetDate
          // startDate indica "no generar instancias antes de esta fecha"
          const effectiveType = newRepeatType || item.repeat.type;
          console.log('Creating new repeat:', { effectiveType, newRepeatType, newEvery, newDays, itemRepeat: item.repeat });

          const newRepeat = {
            type: effectiveType,
            startDate: targetDate,
          };

          // Configurar según el tipo de recurrencia
          if (effectiveType === 'weekdays') {
            newRepeat.days = newDays || item.repeat.days || [];
          } else {
            // days or weeks
            newRepeat.every = newEvery || item.repeat.every || 1;
          }

          console.log('newRepeat:', newRepeat);

          const newItemId = Date.now();
          const newItem = {
            id: newItemId,
            title: item.title,
            description: item.description || '',
            category: item.category,
            effort: item.effort,
            scheduledSlot: targetSlot,
            sortOrder: insertedSortOrder,
            completed: false,
            completedDate: null,
            createdAt: item.createdAt,
            isArchived: false,
            repeat: newRepeat,
            repeatBaseId: item.repeatBaseId ? `${item.repeatBaseId}-following` : undefined,
          };

          // Trigger drop feedback animation for the new item
          setTimeout(() => {
            setJustDroppedItemId(newItemId);
            setTimeout(() => setJustDroppedItemId(null), 300);
          }, 0);

          return [...updated, newItem];
        });
      };

      // Todos los eventos: mover toda la serie
      const handleRecurringMoveAll = (item, originalDate, originalSlot, targetDate, targetSlot, dropIndex) => {
        const dayOffset = getDayDiff(originalDate, targetDate);
        console.log('handleRecurringMoveAll called', { itemId: item.id, originalDate, targetDate, dayOffset });
        const { insertedSortOrder, otherSortOrders } = calculateSortOrdersForDrop(targetDate, targetSlot, dropIndex, item.id);

        setItems(p => p.map(i => {
          if (i.id === item.id) {
            // Actualizar configuración de repeat
            const newRepeat = shiftRepeatConfig(i.repeat, dayOffset);
            const newCreatedAt = shiftDate(i.createdAt, dayOffset);
            console.log('Shifting repeat config:', { oldRepeat: i.repeat, newRepeat, oldCreatedAt: i.createdAt, newCreatedAt });

            return {
              ...i,
              repeat: newRepeat,
              scheduledSlot: targetSlot,
              sortOrder: insertedSortOrder,
              exceptions: shiftExceptions(i.exceptions, dayOffset, targetSlot),
              createdAt: newCreatedAt,
            };
          }

          // Actualizar sortOrder de otros items en el slot destino
          if (otherSortOrders[i.id] !== undefined) {
            if (i.repeat) {
              const newDateOverrides = { ...(i.dateOverrides || {}), [targetDate]: { sortOrder: otherSortOrders[i.id] } };
              return { ...i, dateOverrides: newDateOverrides };
            } else if (i.scheduledDate === targetDate && i.scheduledSlot === targetSlot) {
              return { ...i, sortOrder: otherSortOrders[i.id] };
            }
          }

          return i;
        }));

        // Trigger drop feedback animation for the moved item
        setJustDroppedItemId(item.id);
        setTimeout(() => setJustDroppedItemId(null), 300);
      };

      // Handler principal para borrado de recurrentes
      const handleRecurringDeleteAction = (choice) => {
        if (!recurringDeletePopover) return;
        const { item, exceptionDate, visualDate } = recurringDeletePopover;
        // Save a snapshot of the item before modification (for undo)
        const previousItem = { ...item, exceptions: item.exceptions ? { ...item.exceptions } : undefined, repeat: { ...item.repeat } };

        switch (choice) {
          case 'this': {
            // "Solo este evento": add exception with deleted: true
            setItems(p => p.map(i => {
              if (i.id === item.id) {
                const newExceptions = { ...(i.exceptions || {}) };
                newExceptions[exceptionDate] = {
                  ...(newExceptions[exceptionDate] || {}),
                  deleted: true,
                };
                // Clean up movedTo since we're deleting
                delete newExceptions[exceptionDate].movedTo;
                delete newExceptions[exceptionDate].completed;
                delete newExceptions[exceptionDate].completedDate;
                return { ...i, exceptions: newExceptions };
              }
              return i;
            }));
            setToast({
              message: `"${item.title}" eliminado (este evento)`,
              recurringDeleteUndo: { itemId: item.id, previousItem },
            });
            break;
          }
          case 'following': {
            // "Este y los siguientes": set endDate to day before visualDate
            const endDateObj = new Date(visualDate + 'T00:00:00');
            endDateObj.setDate(endDateObj.getDate() - 1);
            const newEndDate = formatDate(endDateObj);

            setItems(p => p.map(i => {
              if (i.id === item.id) {
                // Clean up exceptions on or after visualDate
                const newExceptions = { ...(i.exceptions || {}) };
                Object.keys(newExceptions).forEach(excDate => {
                  if (excDate >= visualDate) {
                    delete newExceptions[excDate];
                  }
                });
                return {
                  ...i,
                  repeat: { ...i.repeat, endDate: newEndDate },
                  exceptions: Object.keys(newExceptions).length > 0 ? newExceptions : undefined,
                };
              }
              return i;
            }));
            setToast({
              message: `"${item.title}" eliminado (este y siguientes)`,
              recurringDeleteUndo: { itemId: item.id, previousItem },
            });
            break;
          }
          case 'all': {
            // "Todos los eventos": delete the entire item
            const deletedIndex = items.findIndex(i => i.id === item.id);
            setItems(p => p.filter(i => i.id !== item.id));
            if (item.title && item.title.trim() !== '') {
              setToast({
                message: `"${item.title}" eliminado`,
                item: item,
                index: deletedIndex,
              });
            }
            break;
          }
        }
        setRecurringDeletePopover(null);
      };

      const navigateDays = (numDays) => {
        const newBase = new Date(viewBase);
        newBase.setDate(newBase.getDate() + numDays);
        if (newBase >= minDate && newBase <= maxDate) {
          setViewBase(newBase);
        }
      };

      const goToToday = () => {
        const today = new Date(REAL_TODAY);
        setViewBase(today);
        setCurrentMobileDay(today);
        // Scroll to left (beginning) of the calendar view
        if (scrollRef.current) {
          scrollRef.current.scrollTo({ left: 0, behavior: 'smooth' });
        }
        // Also scroll window to top
        window.scrollTo({ top: 0, behavior: 'smooth' });
      };

      // Check if we're at the default view (today is the base)
      const isTodayVisible = useMemo(() => {
        return formatDate(viewBase) === formatDate(REAL_TODAY);
      }, [viewBase]);

      // Update document title based on view position
      useEffect(() => {
        if (isMobile || isTodayVisible) {
          document.title = 'Tudux - Hoy';
        } else if (viewBase < REAL_TODAY) {
          document.title = 'Tudux - Pasado';
        } else {
          document.title = 'Tudux - Futuro';
        }
      }, [isTodayVisible, viewBase, isMobile]);

      // Clear completed items from categories
      const clearCategoryDone = useCallback(() => {
        // Find completed backlog items (no scheduledDate, not recurring, completed)
        const completedBacklogItems = [];
        items.forEach((item, index) => {
          if (item.completed && !item.scheduledDate && !item.repeat) {
            completedBacklogItems.push({ item, index });
          }
        });
        if (completedBacklogItems.length === 0) {
          setToast({ message: 'No hay items completados en categorías' });
          return;
        }
        setItems(prev => prev.filter(item =>
          !(item.completed && !item.scheduledDate && !item.repeat)
        ));
        setToast({
          message: `${completedBacklogItems.length} items eliminados`,
          deletedItems: completedBacklogItems, // Store items with their original indices for undo
        });
      }, [items]);

      // ===== Mobile Functions =====
      const handleMobileScroll = useCallback(() => {
        if (!mobileScrollRef.current || isScrollingRef.current) return;
        const container = mobileScrollRef.current;
        const scrollLeft = container.scrollLeft;
        const width = container.clientWidth;
        const index = Math.round(scrollLeft / width);
        if (index >= 0 && index < days.length) {
          const newDay = days[index].date;
          if (formatDate(newDay) !== formatDate(currentMobileDay)) {
            setCurrentMobileDay(newDay);
          }
        }
      }, [days, currentMobileDay]);

      // Initial mobile scroll to today (instant, no animation)
      const mobileInitializedRef = useRef(false);
      useEffect(() => {
        if (!isMobile || !mobileScrollRef.current || mobileInitializedRef.current) return;
        const index = days.findIndex(d => formatDate(d.date) === formatDate(REAL_TODAY));
        if (index >= 0) {
          const container = mobileScrollRef.current;
          isScrollingRef.current = true;
          container.scrollTo({ left: index * container.clientWidth, behavior: 'instant' });
          mobileInitializedRef.current = true;
          setTimeout(() => { isScrollingRef.current = false; }, 100);
        }
      }, [isMobile, days]);

      // Scroll to day when currentMobileDay changes (e.g., from picker)
      useEffect(() => {
        if (!isMobile || !mobileScrollRef.current) return;
        const index = days.findIndex(d => formatDate(d.date) === formatDate(currentMobileDay));
        if (index >= 0) {
          const container = mobileScrollRef.current;
          const targetScroll = index * container.clientWidth;
          if (Math.abs(container.scrollLeft - targetScroll) > 10) {
            isScrollingRef.current = true;
            container.scrollTo({ left: targetScroll, behavior: 'smooth' });
            setTimeout(() => { isScrollingRef.current = false; }, 300);
          }
        }
      }, [currentMobileDay, isMobile, days]);

      const handleMobileAddClick = () => {
        // Close calendar popover if open
        if (calendarRect) {
          setCalendarRect(null);
        }
        if (mobileViewMode === 'calendar') {
          // In calendar view: create item without title as first item of todo slot
          const newItem = {
            id: Date.now(),
            title: '',
            description: '',
            category: 'temp',
            effort: 1,
            scheduledDate: formatDate(currentMobileDay),
            scheduledSlot: 'todo',
            completed: false,
            completedDate: null,
            createdAt: formatDate(REAL_TODAY),
            isArchived: false,
            repeat: null,
            sortOrder: -1000,
            _isNewItem: true,
          };
          setItems(p => [newItem, ...p]);
          setBottomSheetItem({ item: newItem, visualDate: formatDate(currentMobileDay) });
          // Scroll new item into view using its ID
          const scrollToNewItem = () => {
            const newItemEl = document.querySelector(`[data-item-id="${newItem.id}"]`);
            if (newItemEl) {
              newItemEl.scrollIntoView({ block: 'start', behavior: 'instant' });
            }
          };
          setTimeout(scrollToNewItem, 50);
          setTimeout(scrollToNewItem, 300);
        } else {
          // In categories view: create item in backlog (existing behavior)
          const newItem = {
            id: Date.now(),
            title: '',
            description: '',
            category: 'temp',
            effort: 1,
            scheduledDate: null,
            scheduledSlot: null,
            completed: false,
            completedDate: null,
            createdAt: formatDate(REAL_TODAY),
            isArchived: false,
            repeat: null,
            sortOrder: -1000,
            _isNewItem: true,
          };
          setItems(p => [newItem, ...p]);
          setBottomSheetItem({ item: newItem, visualDate: null });
          // Scroll new item into view using its ID
          const scrollToNewItem = () => {
            const newItemEl = document.querySelector(`[data-item-id="${newItem.id}"]`);
            if (newItemEl) {
              newItemEl.scrollIntoView({ block: 'start', behavior: 'instant' });
            }
          };
          setTimeout(scrollToNewItem, 50);
          setTimeout(scrollToNewItem, 300);
        }
      };

      const handleBottomSheetClose = () => {
        setBottomSheetClosing(true);
        setTimeout(() => {
          setBottomSheetItem(null);
          setBottomSheetClosing(false);
        }, 200);
      };

      const handleBottomSheetSave = (data) => {
        handleSave(data);
        setBottomSheetClosing(true);
        setTimeout(() => {
          setBottomSheetItem(null);
          setBottomSheetClosing(false);
        }, 200);
      };

      const handleMobileEdit = (item, rect, visualDate) => {
        // Don't open item if calendar popover is open - close calendar first
        if (calendarRect) {
          setCalendarRect(null);
          lastPopoverCloseTime = Date.now(); // Prevent shimmer on next item tap
          return; // Don't open bottom sheet, just close calendar
        }
        setBottomSheetItem({ item, visualDate });
      };

      const expandAll = () => {
        const allExpanded = {};
        const allGroupsExp = {};
        categories.forEach(c => {
          allExpanded[c.id] = true;
          allGroupsExp[c.id] = { backlog: true, scheduled: true, done: true };
        });
        setExpanded(allExpanded);
        setCategoryGroupsExp(allGroupsExp);
      };

      const collapseAll = () => {
        const allGroupsExp = {};
        categories.forEach(c => {
          allGroupsExp[c.id] = { backlog: false, scheduled: false, done: false };
        });
        setExpanded({});
        setCategoryGroupsExp(allGroupsExp);
      };

      const clearDone = () => {
        // Hide completed items from sidebar only (calendar Hecho sections are not affected)
        const itemsToHide = items.filter(i => i.completed && !i.hiddenFromSidebar);
        if (itemsToHide.length === 0) return;

        const hiddenIds = itemsToHide.map(i => i.id);
        setItems(p => p.map(i => i.completed ? { ...i, hiddenFromSidebar: true } : i));

        setToast({
          message: `${itemsToHide.length} item${itemsToHide.length > 1 ? 's' : ''} oculto${itemsToHide.length > 1 ? 's' : ''}`,
          hiddenIds,
        });
      };

      // Navigate to a scheduled item in the calendar and open its edit popover
      const handleScheduledItemClick = useCallback((item) => {
        // Find the target date - for recurring items, find next occurrence (including today)
        let targetDate = item.scheduledDate;
        if (item.repeat && !targetDate) {
          // Find next occurrence for recurring items
          const todayStr = formatDate(REAL_TODAY);
          // Look for the next visible instance in allItemsWithRecurring
          const instances = allItemsWithRecurring.filter(i => {
            const baseId = typeof i.id === 'string' ? parseInt(i.id.split('-')[0]) : i.id;
            return (baseId === item.id || i.originalId === item.id) && i.scheduledDate >= todayStr;
          }).sort((a, b) => a.scheduledDate.localeCompare(b.scheduledDate));
          if (instances.length > 0) {
            targetDate = instances[0].scheduledDate;
          }
        }

        if (!targetDate) return;

        // For mobile: just open the edit popover (bottom sheet) without navigating
        if (isMobile) {
          setBottomSheetItem({ item: items.find(i => i.id === item.id) || item, visualDate: targetDate });
          return;
        }

        // Navigate calendar to show the target date
        const targetDateObj = new Date(targetDate + 'T00:00:00');
        setViewBase(targetDateObj);

        // After a short delay (to allow render), find the item in calendar and show shimmer + popover
        setTimeout(() => {
          // Find the item element in the calendar
          const itemId = item.repeat ? `${item.id}-${targetDate}` : item.id;
          const itemEl = document.querySelector(`[data-item-id="${itemId}"]`);

          if (itemEl) {
            // Scroll to make it visible if needed
            itemEl.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });

            // Trigger reverse shimmer animation
            setJustShimmeredItemId(typeof itemId === 'string' ? parseInt(itemId.split('-')[0]) : itemId);
            setTimeout(() => setJustShimmeredItemId(null), 300);

            // Show edit popover after shimmer starts
            setTimeout(() => {
              const rect = itemEl.getBoundingClientRect();
              // For recurring items, find the instance to edit
              const instanceItem = allItemsWithRecurring.find(i =>
                String(i.id) === String(itemId) ||
                (i.originalId === item.id && i.scheduledDate === targetDate)
              ) || item;
              setEditPopover({ item: items.find(i => i.id === item.id) || item, rect, visualDate: targetDate });
            }, 100);
          }
        }, 100);
      }, [allItemsWithRecurring, items, isMobile, days]);

      // Mobile helper: get items for current mobile day
      const mobileIsToday = formatDate(currentMobileDay) === formatDate(REAL_TODAY);

      // ===== RENDER =====
      if (isMobile) {
        // MOBILE LAYOUT
        return (
          <div className="app-mobile">
            {/* Floating header buttons - only visible in calendar mode */}
            {mobileViewMode === 'calendar' && (
              <div className="floating-header">
                {!mobileIsToday && <button onClick={goToToday} onTouchStart={(e) => e.stopPropagation()} className="btn btn-primary" style={{ fontSize: '0.75rem', pointerEvents: 'auto', touchAction: 'none' }}>Hoy</button>}
                <button onClick={(e) => setCalendarRect(e.currentTarget.getBoundingClientRect())} onTouchStart={(e) => e.stopPropagation()} className="btn" style={{ fontWeight: '600', fontSize: '0.75rem', pointerEvents: 'auto', touchAction: 'none' }}>{getShortMonthName(currentMobileDay)}</button>
              </div>
            )}

            {/* Mobile Content - Both views side by side with slide animation */}
            <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden' }}>
              <div className={`mobile-views-container view-${mobileViewMode}`}>
                {/* Mobile Calendar - Horizontal scroll with snap */}
                <div className="mobile-view-panel">
                  <div
                    ref={mobileScrollRef}
                    className="mobile-day-scroll"
                    style={{ flex: 1, display: 'flex' }}
                    onScroll={handleMobileScroll}
                  >
                    {days.map(day => (
                      <MobileDayColumn
                        key={formatDate(day.date)}
                        day={day}
                        items={allItemsWithRecurring}
                        categories={categories}
                        dayEnergy={dayEnergy}
                        onComplete={handleComplete}
                        onEdit={handleMobileEdit}
                        onDelete={handleDelete}
                        onDrop={handleDrop}
                        onAdd={handleSave}
                        onSetEnergy={(d, e) => setDayEnergy(p => ({ ...p, [d]: e }))}
                        justDroppedItemId={justDroppedItemId}
                        onGoToToday={goToToday}
                        onOpenCalendar={(e) => setCalendarRect(e.currentTarget.getBoundingClientRect())}
                        monthName={getShortMonthName(day.date)}
                        draggingItemType={draggingItemType}
                        draggingRecurringRange={draggingRecurringRange}
                      />
                    ))}
                  </div>
                </div>

                {/* Mobile Categories - vertical scroll, one column */}
                <div className="mobile-view-panel" style={{ background: 'var(--bg-header)', display: 'flex', flexDirection: 'column' }}>
                  {/* Vertical scroll container */}
                  <div
                    style={{
                      flex: 1,
                      overflowY: 'auto',
                      WebkitOverflowScrolling: 'touch',
                      padding: '10px 12px 100px',
                    }}
                  >
                    {categories.map((cat, catIndex) => {
                      const categoryItems = allItemsWithRecurring.filter(i => i.category === cat.id);
                      const backlogItems = categoryItems.filter(i =>
                        !i.scheduledDate && !i.isArchived && !i.repeat
                      ).sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));

                      return (
                        <div key={cat.id}>
                          {/* Category header - same style as day headers */}
                          <div
                            onClick={() => {
                              // Close calendar popover if open
                              if (calendarRect) {
                                setCalendarRect(null);
                              }
                              const minSortOrder = backlogItems.length > 0 ? Math.min(...backlogItems.map(i => i.sortOrder || 0)) : 0;
                              const newItem = {
                                id: Date.now(),
                                title: '',
                                description: '',
                                category: cat.id,
                                effort: 1,
                                scheduledDate: null,
                                scheduledSlot: null,
                                completed: false,
                                completedDate: null,
                                createdAt: formatDate(REAL_TODAY),
                                isArchived: false,
                                repeat: null,
                                sortOrder: minSortOrder - 1,
                                _isNewItem: true,
                              };
                              setItems(p => [newItem, ...p]);
                              setBottomSheetItem({ item: newItem, visualDate: null });
                            }}
                            style={{
                              padding: catIndex === 0 ? '8px 4px 6px' : '24px 4px 6px',
                              cursor: 'pointer',
                              display: 'flex',
                              alignItems: 'center',
                            }}
                          >
                            <div style={{ fontSize: '1.125rem', color: cat.color }}>
                              <span style={{ fontWeight: '700' }}>{cat.name}</span>
                              <span style={{ fontWeight: '400', opacity: 0.7 }}> ({backlogItems.length})</span>
                            </div>
                          </div>

                          {/* Items list - directly on background */}
                          <div style={{ padding: '0 4px' }}>
                            {backlogItems.map((item) => (
                              <div key={item.id}>
                                <ItemCard
                                  item={item}
                                  categories={categories}
                                  onComplete={handleComplete}
                                  onEdit={handleMobileEdit}
                                  onDelete={handleDelete}
                                  onToggleImportant={handleToggleImportant}
                                  inSidebar={true}
                                  justDroppedItemId={justDroppedItemId}
                                />
                              </div>
                            ))}
                            {backlogItems.length === 0 && (
                              <div style={{ color: 'var(--text-muted)', fontSize: '0.875rem', padding: '8px 4px' }}>
                                Sin items
                              </div>
                            )}
                          </div>
                        </div>
                      );
                    })}

                  </div>
                </div>
              </div>
            </div>

            {/* Mobile Footer - Two large tap zones */}
            <div className="mobile-footer">
              {/* FAB - positioned relative to footer */}
              <button
                className="btn btn-primary fab"
                onClick={handleMobileAddClick}
              >
                Agregar
              </button>
              {/* Left half - Calendar */}
              <button
                onClick={() => setMobileViewMode('calendar')}
                className="footer-tab footer-tab-left"
              >
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke={mobileViewMode === 'calendar' ? 'var(--text-primary)' : 'var(--text-muted)'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ opacity: mobileViewMode === 'calendar' ? 1 : 0.35, filter: mobileViewMode === 'calendar' ? 'none' : 'grayscale(100%)' }}>
                  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
                  <line x1="16" y1="2" x2="16" y2="6"/>
                  <line x1="8" y1="2" x2="8" y2="6"/>
                  <line x1="3" y1="10" x2="21" y2="10"/>
                </svg>
              </button>
              {/* Right half - Categories */}
              <button
                onClick={() => setMobileViewMode('categories')}
                className="footer-tab footer-tab-right"
              >
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke={mobileViewMode === 'categories' ? 'var(--text-primary)' : 'var(--text-muted)'} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" style={{ opacity: mobileViewMode === 'categories' ? 1 : 0.35, filter: mobileViewMode === 'categories' ? 'none' : 'grayscale(100%)' }}>
                  <rect x="3" y="3" width="7" height="7"/>
                  <rect x="14" y="3" width="7" height="7"/>
                  <rect x="14" y="14" width="7" height="7"/>
                  <rect x="3" y="14" width="7" height="7"/>
                </svg>
              </button>
            </div>

            {/* Bottom Sheet for mobile editing */}
            {bottomSheetItem && (
              <BottomSheet
                item={items.find(i => i.id === bottomSheetItem.item.id) || bottomSheetItem.item}
                visualDate={bottomSheetItem.visualDate}
                categories={categories}
                onSave={handleBottomSheetSave}
                onDelete={handleDelete}
                onComplete={handleComplete}
                onToggleImportant={handleToggleImportant}
                onDuplicate={handleDuplicate}
                onClose={handleBottomSheetClose}
                closing={bottomSheetClosing}
              />
            )}

            {/* Calendar Popover */}
            {calendarRect && <CalendarPopover baseDate={currentMobileDay} visibleDates={days.map(d => d.date)} onClose={() => setCalendarRect(null)} targetRect={calendarRect} onSelectDate={(d) => { setCurrentMobileDay(d); setCalendarRect(null); }} isMobile={true} />}

            {/* New Category Popover */}
            {newCatRect && <EditCategoryPopover category={{}} itemCount={0} onSave={handleEditCategory} onDelete={() => {}} onClose={() => setNewCatRect(null)} targetRect={newCatRect} />}

            {/* Recurring Action Popover (for date changes on recurring items) */}
            {recurringEditPopover && <RecurringActionPopover
              item={recurringEditPopover.item}
              originalDate={recurringEditPopover.originalDate}
              visualDate={recurringEditPopover.visualDate}
              targetDate={recurringEditPopover.targetDate}
              targetSlot={recurringEditPopover.targetSlot}
              action={recurringEditPopover.action}
              targetRect={recurringEditPopover.rect}
              pendingItemId={recurringEditPopover.pendingItemId}
              onConfirm={handleRecurringAction}
              onCancel={() => { setRecurringEditPopover(null); setPendingRecurringDrop(null); }}
            />}

            {/* Recurring Delete Popover */}
            {recurringDeletePopover && <RecurringDeletePopover
              item={recurringDeletePopover.item}
              targetRect={recurringDeletePopover.rect}
              onConfirm={handleRecurringDeleteAction}
              onCancel={() => setRecurringDeletePopover(null)}
            />}

            {/* Toast */}
            {toast && <Toast message={toast.message} onUndo={handleUndoDelete} onClose={() => setToast(null)} />}
          </div>
        );
      }

      // ===== DESKTOP LAYOUT - Two rows: Calendar top, Categories bottom =====
      return (
        <div className="app-desktop">
          {/* Row 1: Calendar with header - 59% height */}
          <div className="calendar-row">
            {/* Calendar header */}
            <div className="header-bar">
              <button onClick={(e) => setCalendarRect(e.currentTarget.getBoundingClientRect())} className="btn" style={{ fontWeight: '600', fontSize: '0.5625rem', display: 'flex', alignItems: 'center', gap: '4px', background: 'var(--bg-button)' }}>
                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
                  <line x1="16" y1="2" x2="16" y2="6"></line>
                  <line x1="8" y1="2" x2="8" y2="6"></line>
                  <line x1="3" y1="10" x2="21" y2="10"></line>
                </svg>
                {getShortMonthName(viewBase)} {viewBase.getFullYear()}
              </button>
              <div className="nav-group">
                <button onClick={() => navigateDays(-12)} className="btn" style={{ background: 'var(--bg-button)' }}><span className="btn-top-adjust">««</span></button>
                <button onClick={() => navigateDays(-1)} className="btn" style={{ background: 'var(--bg-button)' }}><span className="btn-top-adjust">«</span></button>
              </div>
              <span style={{ fontSize: '0.6875rem', fontWeight: '600', color: 'var(--text-primary)', minWidth: '70px', textAlign: 'center' }}>{rangeText}</span>
              <div className="nav-group">
                <button onClick={() => navigateDays(1)} className="btn" style={{ background: 'var(--bg-button)' }}><span className="btn-top-adjust">»</span></button>
                <button onClick={() => navigateDays(12)} className="btn" style={{ background: 'var(--bg-button)' }}><span className="btn-top-adjust">»»</span></button>
              </div>
              <button onClick={goToToday} className="btn" style={{ background: isTodayVisible ? 'var(--bg-button)' : 'var(--accent-blue)', color: isTodayVisible ? 'var(--text-secondary)' : '#FFF' }}>Hoy</button>
              <div className="flex-spacer" />
              <button onClick={clearCategoryDone} className="btn" style={{ background: 'var(--bg-button)' }}>Borrar hechos</button>
              <button onClick={() => setCategoriesModalOpen(true)} className="btn" style={{ background: 'var(--bg-button)' }}>Editar categorías</button>
            </div>
            <div ref={scrollRef} onDragOver={handleCalendarDragOver} className="calendar-scroll">
              {days.map((day, i) => <DayColumn key={formatDate(day.date)} day={day} items={allItemsWithRecurring} categories={categories} dayEnergy={dayEnergy} onComplete={handleComplete} onEdit={handleEdit} onDelete={handleDelete} onToggleImportant={handleToggleImportant} onDrop={handleDrop} onAdd={handleSave} onSetEnergy={(d, e) => setDayEnergy(p => ({ ...p, [d]: e }))} isSticky={false} justDroppedItemId={justDroppedItemId} draggingItemType={draggingItemType} onDragTypeChange={setDraggingItemType} draggingRecurringRange={draggingRecurringRange} />)}
            </div>
          </div>

          {/* Row 2: Categories - horizontal scroll - 45% height */}
          <div className="categories-row">
            <div className="categories-scroll">
              {categories.map(cat => (
                <div key={cat.id}
                  onDragOver={(e) => { if (e.dataTransfer.types.includes('categoryid') && !cat.isFixed) { e.preventDefault(); setDragOverCat(cat.id); }}}
                  onDragLeave={() => setDragOverCat(null)}
                  onDrop={(e) => { const id = e.dataTransfer.getData('categoryId'); if (id && !cat.isFixed) { handleReorderCategory(id, cat.id); setDragOverCat(null); }}}
                  style={{ outline: dragOverCat === cat.id ? '2px dashed var(--accent-blue)' : 'none' }}>
                  <CategoryColumnSimple category={cat} items={allItemsWithRecurring} allItems={items} categories={categories} onComplete={handleComplete} onEdit={handleEdit} onAdd={handleSave} onDrop={handleDropCategory} onEditCategory={handleEditCategory} onDelete={handleDelete} onToggleImportant={handleToggleImportant} onSidebarGroupDrop={handleSidebarGroupDrop} justDroppedItemId={justDroppedItemId} draggingItemType={draggingItemType} onDragTypeChange={setDraggingItemType} />
                </div>
              ))}
              {/* Add category button - entire cell is clickable */}
              <div
                onClick={(e) => {
                  if (!editPopover && !newCatRect) {
                    const rect = e.currentTarget.getBoundingClientRect();
                    setNewCatRect(rect);
                  }
                }}
                className="add-cat-cell"
                style={{ cursor: editPopover ? 'default' : 'pointer', opacity: editPopover ? 0.5 : 1 }}
              >
                <span className="add-cat-plus">+</span>
              </div>
            </div>
          </div>

          {calendarRect && <CalendarPopover baseDate={viewBase} visibleDates={days.map(d => d.date)} onClose={() => setCalendarRect(null)} targetRect={calendarRect} onSelectDate={(d) => { setViewBase(d); setCalendarRect(null); }} />}
          {editPopover && <AddEditItemPopover categories={categories} editItem={editPopover.item} visualDate={editPopover.visualDate} onSave={handleSave} onDelete={handleDelete} onComplete={handleComplete} onDuplicate={handleDuplicate} onClose={() => {
            // Delete empty new items when closing without saving
            if (editPopover.item?._isNewItem && !editPopover.item?.title?.trim()) {
              setItems(p => p.filter(i => i.id !== editPopover.item.id));
            }
            setEditPopover(null);
          }} targetRect={editPopover.rect} />}
          {newCatRect && <EditCategoryPopover category={{}} itemCount={0} onSave={handleEditCategory} onDelete={() => {}} onClose={() => setNewCatRect(null)} targetRect={newCatRect} />}
          {categoriesModalOpen && <CategoriesModal categories={categories} items={items} onSave={handleEditCategory} onDelete={(id) => setCategories(prev => prev.filter(c => c.id !== id))} onReorder={(order) => setCategories(prev => { const fixed = prev.filter(c => c.isFixed); const nonFixed = order.map(id => prev.find(c => c.id === id)).filter(Boolean); return [...fixed, ...nonFixed]; })} onClose={() => setCategoriesModalOpen(false)} />}
          {recurringEditPopover && <RecurringActionPopover
            item={recurringEditPopover.item}
            originalDate={recurringEditPopover.originalDate}
            visualDate={recurringEditPopover.visualDate}
            targetDate={recurringEditPopover.targetDate}
            targetSlot={recurringEditPopover.targetSlot}
            action={recurringEditPopover.action}
            targetRect={recurringEditPopover.rect}
            pendingItemId={recurringEditPopover.pendingItemId}
            onConfirm={handleRecurringAction}
            onCancel={() => { setRecurringEditPopover(null); setPendingRecurringDrop(null); }}
          />}
          {recurringDeletePopover && <RecurringDeletePopover
            item={recurringDeletePopover.item}
            targetRect={recurringDeletePopover.rect}
            onConfirm={handleRecurringDeleteAction}
            onCancel={() => setRecurringDeletePopover(null)}
          />}
          {recurringSavePopover && <RecurringSavePopover
            itemTitle={recurringSavePopover.cleanData.title}
            targetRect={recurringSavePopover.rect}
            onThis={handleRecurringSaveThis}
            onFollowing={handleRecurringSaveFollowing}
            onCancel={() => { setRecurringSavePopover(null); setEditPopover(null); }}
          />}
          {removeRecurrenceAlert && <RemoveRecurrenceAlertPopover
            itemTitle={removeRecurrenceAlert.item.title}
            targetRect={removeRecurrenceAlert.coords ? { left: removeRecurrenceAlert.coords.x, top: removeRecurrenceAlert.coords.y, width: 0, height: 0 } : null}
            onConfirm={() => {
              // Create exception that removes recurrence for this date only
              const { item, date, slot, dropIndex } = removeRecurrenceAlert;
              setItems(p => p.map(i => {
                if (i.id === item.id) {
                  // Add exception to skip this date from recurring
                  const newExceptions = { ...(i.exceptions || {}), [date]: { skip: true } };
                  return { ...i, exceptions: newExceptions };
                }
                return i;
              }));
              // Create new non-recurring item at the drop position
              const newId = Date.now();
              const newItem = {
                id: newId,
                title: item.title,
                description: item.description || '',
                category: item.category,
                effort: item.effort || 0,
                scheduledDate: date,
                scheduledSlot: slot || 'todo',
                sortOrder: dropIndex || 0,
                completed: false,
                completedDate: null,
                isArchived: false,
                hiddenFromSidebar: false,
                isImportant: false,
                repeat: null,
                exceptions: null,
                dateOverrides: null,
              };
              setItems(p => [...p, newItem]);
              // Reorder items to put new item at correct position
              performDrop(newId, date, slot, dropIndex);
              setRemoveRecurrenceAlert(null);
            }}
            onCancel={() => setRemoveRecurrenceAlert(null)}
          />}
          {toast && <Toast message={toast.message} onUndo={handleUndoDelete} onClose={() => setToast(null)} />}
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
